import * as qs from "query-string";
import { getWindowMetadata } from "@walletconnect/window-metadata";
import { getDocument, getLocation, getNavigator } from "@walletconnect/window-getters";
export function isNode() {
    return (typeof process !== "undefined" &&
        typeof process.versions !== "undefined" &&
        typeof process.versions.node !== "undefined");
}
export function isReactNative() {
    return !getDocument() && !!getNavigator() && navigator.product === "ReactNative";
}
export function isBrowser() {
    return !isNode() && !!getNavigator();
}
export function getEnvironment() {
    if (isReactNative())
        return "react-native";
    if (isNode())
        return "node";
    if (isBrowser())
        return "browser";
    return "unknown";
}
export function appendToQueryString(queryString, newQueryParams) {
    let queryParams = qs.parse(queryString);
    queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
    queryString = qs.stringify(queryParams);
    return queryString;
}
export function getAppMetadata() {
    return getWindowMetadata() || undefined;
}
export function getRelayClientMetadata(protocol, version) {
    var _a;
    const env = getEnvironment();
    const metadata = { protocol, version, env };
    if (env === "browser") {
        metadata.host = ((_a = getLocation()) === null || _a === void 0 ? void 0 : _a.host) || "";
    }
    return metadata;
}
export function formatRelayRpcUrl(protocol, version, url) {
    const splitUrl = url.split("?");
    const params = getRelayClientMetadata(protocol, version);
    const queryString = appendToQueryString(splitUrl[1] || "", params);
    return splitUrl[0] + "?" + queryString;
}
export function assertType(obj, key, type) {
    if (!obj[key] || typeof obj[key] !== type) {
        throw new Error(`Missing or invalid "${key}" param`);
    }
}
export function hasOverlap(a, b) {
    const matches = a.filter(x => b.includes(x));
    return matches.length === a.length;
}
export function mapToObj(map) {
    return Object.fromEntries(map.entries());
}
export function objToMap(obj) {
    return new Map(Object.entries(obj));
}
export function mapEntries(obj, cb) {
    const res = {};
    Object.keys(obj).forEach(key => {
        res[key] = cb(obj[key]);
    });
    return res;
}
export const enumify = (x) => x;
export function capitalizeWord(word) {
    return word.trim().replace(/^\w/, c => c.toUpperCase());
}
export function capitalize(str) {
    return str
        .split(" ")
        .map(w => capitalizeWord(w))
        .join(" ");
}
//# sourceMappingURL=misc.js.map