"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatInvalidResult = exports.formatValidResult = exports.isValidationInvalid = exports.isValidUrl = exports.isValidAccountId = exports.isValidChainId = exports.isValidString = exports.isValidArray = exports.validateBlockchainState = exports.validateNotificationPermissions = exports.validateJsonRpcPermissions = exports.validateBlockchainPermissions = exports.validateSessionRespondParams = exports.validateSessionProposeParams = exports.validateSessionProposeParamsMetadata = exports.validateSessionProposeParamsPermissions = exports.isSubscriptionUpdatedEvent = exports.isSessionFailed = exports.isSessionResponded = exports.isSessionRespondedStatus = exports.isPairingFailed = exports.isPairingResponded = exports.isPairingRespondedStatus = exports.isSequenceFailed = exports.isSequenceResponded = exports.isSequenceRespondedStatus = exports.isSignalTypeUri = exports.isSignalTypePairing = void 0;
const error_1 = require("./error");
function isSignalTypePairing(signal) {
    return signal.method === "pairing";
}
exports.isSignalTypePairing = isSignalTypePairing;
function isSignalTypeUri(signal) {
    return signal.method === "uri";
}
exports.isSignalTypeUri = isSignalTypeUri;
function isSequenceRespondedStatus(status) {
    return status === "responded";
}
exports.isSequenceRespondedStatus = isSequenceRespondedStatus;
function isSequenceResponded(pending) {
    return isSequenceRespondedStatus(pending.status) && "outcome" in pending;
}
exports.isSequenceResponded = isSequenceResponded;
function isSequenceFailed(outcome) {
    return "reason" in outcome;
}
exports.isSequenceFailed = isSequenceFailed;
function isPairingRespondedStatus(status) {
    return status === "responded";
}
exports.isPairingRespondedStatus = isPairingRespondedStatus;
function isPairingResponded(pending) {
    return isPairingRespondedStatus(pending.status) && "outcome" in pending;
}
exports.isPairingResponded = isPairingResponded;
function isPairingFailed(outcome) {
    return "reason" in outcome;
}
exports.isPairingFailed = isPairingFailed;
function isSessionRespondedStatus(status) {
    return status === "responded";
}
exports.isSessionRespondedStatus = isSessionRespondedStatus;
function isSessionResponded(pending) {
    return isPairingRespondedStatus(pending.status) && "outcome" in pending;
}
exports.isSessionResponded = isSessionResponded;
function isSessionFailed(outcome) {
    return "reason" in outcome;
}
exports.isSessionFailed = isSessionFailed;
function isSubscriptionUpdatedEvent(event) {
    return "update" in event;
}
exports.isSubscriptionUpdatedEvent = isSubscriptionUpdatedEvent;
function validateSessionProposeParamsPermissions(permissions) {
    const blockchainPermissionsValidation = validateBlockchainPermissions(permissions.blockchain);
    if (isValidationInvalid(blockchainPermissionsValidation)) {
        return blockchainPermissionsValidation;
    }
    const jsonRpcPermissionsValidation = validateJsonRpcPermissions(permissions.jsonrpc);
    if (isValidationInvalid(jsonRpcPermissionsValidation)) {
        return jsonRpcPermissionsValidation;
    }
    const notificationPermissionsValidation = validateNotificationPermissions(permissions.notifications);
    if (isValidationInvalid(notificationPermissionsValidation)) {
        return notificationPermissionsValidation;
    }
    return formatValidResult();
}
exports.validateSessionProposeParamsPermissions = validateSessionProposeParamsPermissions;
function validateSessionProposeParamsMetadata(metadata) {
    if (!isValidString(metadata.name)) {
        return formatInvalidResult(error_1.ERROR.MISSING_OR_INVALID.format({ name: "metadata name" }));
    }
    if (!isValidString(metadata.description)) {
        return formatInvalidResult(error_1.ERROR.MISSING_OR_INVALID.format({ name: "metadata description" }));
    }
    if (typeof metadata.url === "undefined" || !isValidUrl(metadata.url)) {
        return formatInvalidResult(error_1.ERROR.MISSING_OR_INVALID.format({ name: "metadata url" }));
    }
    if (typeof metadata.icons === "undefined" || !isValidArray(metadata.icons, isValidUrl)) {
        return formatInvalidResult(error_1.ERROR.MISSING_OR_INVALID.format({ name: "metadata icons" }));
    }
    return formatValidResult();
}
exports.validateSessionProposeParamsMetadata = validateSessionProposeParamsMetadata;
function validateSessionProposeParams(params) {
    const permissionsValidation = validateSessionProposeParamsPermissions(params.permissions);
    if (isValidationInvalid(permissionsValidation)) {
        return permissionsValidation;
    }
    const metadataValidation = validateSessionProposeParamsMetadata(params.metadata);
    if (isValidationInvalid(metadataValidation)) {
        return metadataValidation;
    }
    return formatValidResult();
}
exports.validateSessionProposeParams = validateSessionProposeParams;
function validateSessionRespondParams(params) {
    if (params.approved) {
        if (typeof params.response === "undefined") {
            return formatInvalidResult(error_1.ERROR.MISSING_RESPONSE.format({ context: "session" }));
        }
        const stateValidation = validateBlockchainState(params.response.state, params.proposal.permissions.blockchain);
        if (isValidationInvalid(stateValidation)) {
            return stateValidation;
        }
        const metadataValidation = validateSessionProposeParamsMetadata(params.response.metadata);
        if (isValidationInvalid(metadataValidation)) {
            return metadataValidation;
        }
    }
    return formatValidResult();
}
exports.validateSessionRespondParams = validateSessionRespondParams;
function validateBlockchainPermissions(blockchain) {
    if (typeof blockchain === "undefined" ||
        typeof blockchain.chains === "undefined" ||
        !isValidArray(blockchain.chains, isValidChainId)) {
        return formatInvalidResult(error_1.ERROR.MISSING_OR_INVALID.format({ name: "blockchain permissions" }));
    }
    return formatValidResult();
}
exports.validateBlockchainPermissions = validateBlockchainPermissions;
function validateJsonRpcPermissions(jsonrpc) {
    if (typeof jsonrpc === "undefined" ||
        typeof jsonrpc.methods === "undefined" ||
        !isValidArray(jsonrpc.methods, isValidString)) {
        return formatInvalidResult(error_1.ERROR.MISSING_OR_INVALID.format({ name: "jsonrpc permissions" }));
    }
    return formatValidResult();
}
exports.validateJsonRpcPermissions = validateJsonRpcPermissions;
function validateNotificationPermissions(notifications) {
    if (typeof notifications === "undefined" ||
        typeof notifications.types === "undefined" ||
        !isValidArray(notifications.types, isValidString)) {
        return formatInvalidResult(error_1.ERROR.MISSING_OR_INVALID.format({ name: "notification permissions" }));
    }
    return formatValidResult();
}
exports.validateNotificationPermissions = validateNotificationPermissions;
function validateBlockchainState(state, blockchain) {
    if (typeof blockchain === "undefined" ||
        typeof blockchain.chains === "undefined" ||
        !isValidArray(blockchain.chains, isValidChainId)) {
        return formatInvalidResult(error_1.ERROR.MISSING_OR_INVALID.format({ name: "blockchain permissions" }));
    }
    if (typeof state === "undefined" ||
        typeof state.accounts === "undefined" ||
        !isValidArray(state.accounts, isValidAccountId)) {
        return formatInvalidResult(error_1.ERROR.MISSING_OR_INVALID.format({ name: "state accounts" }));
    }
    const mismatched = state.accounts.filter(accountId => {
        const chainId = accountId.split("@")[1];
        return !blockchain.chains.includes(chainId);
    });
    if (mismatched.length) {
        return formatInvalidResult(error_1.ERROR.MISMATCHED_ACCOUNTS.format({ mismatched }));
    }
    return formatValidResult();
}
exports.validateBlockchainState = validateBlockchainState;
function isValidArray(arr, itemCondition) {
    if (Array.isArray(arr)) {
        if (typeof itemCondition !== "undefined" && arr.length) {
            const matches = arr.filter(itemCondition);
            return matches.length === arr.length;
        }
        else {
            return true;
        }
    }
    return false;
}
exports.isValidArray = isValidArray;
function isValidString(value) {
    return typeof value === "string" && !!value.trim();
}
exports.isValidString = isValidString;
function isValidChainId(value) {
    if (isValidString(value) && value.includes(":")) {
        const split = value.split(":");
        return split.length === 2;
    }
    return false;
}
exports.isValidChainId = isValidChainId;
function isValidAccountId(value) {
    if (isValidString(value) && value.includes("@")) {
        const split = value.split("@");
        if (split.length === 2) {
            return !!split[0] && isValidChainId(split[1]);
        }
    }
    return false;
}
exports.isValidAccountId = isValidAccountId;
function isValidUrl(value) {
    if (isValidString(value)) {
        try {
            const url = new URL(value);
            return typeof url !== "undefined";
        }
        catch (e) {
            return false;
        }
    }
    return false;
}
exports.isValidUrl = isValidUrl;
function isValidationInvalid(validation) {
    return ("valid" in validation &&
        validation.valid === false &&
        "error" in validation &&
        typeof validation.error.code === "number" &&
        typeof validation.error.message === "string");
}
exports.isValidationInvalid = isValidationInvalid;
function formatValidResult() {
    return { valid: true };
}
exports.formatValidResult = formatValidResult;
function formatInvalidResult(error) {
    return { valid: false, error };
}
exports.formatInvalidResult = formatInvalidResult;
//# sourceMappingURL=validators.js.map