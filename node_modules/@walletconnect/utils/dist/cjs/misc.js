"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.capitalize = exports.capitalizeWord = exports.enumify = exports.mapEntries = exports.objToMap = exports.mapToObj = exports.hasOverlap = exports.assertType = exports.formatRelayRpcUrl = exports.getRelayClientMetadata = exports.getAppMetadata = exports.appendToQueryString = exports.getEnvironment = exports.isBrowser = exports.isReactNative = exports.isNode = void 0;
const tslib_1 = require("tslib");
const qs = tslib_1.__importStar(require("query-string"));
const window_metadata_1 = require("@walletconnect/window-metadata");
const window_getters_1 = require("@walletconnect/window-getters");
function isNode() {
    return (typeof process !== "undefined" &&
        typeof process.versions !== "undefined" &&
        typeof process.versions.node !== "undefined");
}
exports.isNode = isNode;
function isReactNative() {
    return !window_getters_1.getDocument() && !!window_getters_1.getNavigator() && navigator.product === "ReactNative";
}
exports.isReactNative = isReactNative;
function isBrowser() {
    return !isNode() && !!window_getters_1.getNavigator();
}
exports.isBrowser = isBrowser;
function getEnvironment() {
    if (isReactNative())
        return "react-native";
    if (isNode())
        return "node";
    if (isBrowser())
        return "browser";
    return "unknown";
}
exports.getEnvironment = getEnvironment;
function appendToQueryString(queryString, newQueryParams) {
    let queryParams = qs.parse(queryString);
    queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
    queryString = qs.stringify(queryParams);
    return queryString;
}
exports.appendToQueryString = appendToQueryString;
function getAppMetadata() {
    return window_metadata_1.getWindowMetadata() || undefined;
}
exports.getAppMetadata = getAppMetadata;
function getRelayClientMetadata(protocol, version) {
    var _a;
    const env = getEnvironment();
    const metadata = { protocol, version, env };
    if (env === "browser") {
        metadata.host = ((_a = window_getters_1.getLocation()) === null || _a === void 0 ? void 0 : _a.host) || "";
    }
    return metadata;
}
exports.getRelayClientMetadata = getRelayClientMetadata;
function formatRelayRpcUrl(protocol, version, url) {
    const splitUrl = url.split("?");
    const params = getRelayClientMetadata(protocol, version);
    const queryString = appendToQueryString(splitUrl[1] || "", params);
    return splitUrl[0] + "?" + queryString;
}
exports.formatRelayRpcUrl = formatRelayRpcUrl;
function assertType(obj, key, type) {
    if (!obj[key] || typeof obj[key] !== type) {
        throw new Error(`Missing or invalid "${key}" param`);
    }
}
exports.assertType = assertType;
function hasOverlap(a, b) {
    const matches = a.filter(x => b.includes(x));
    return matches.length === a.length;
}
exports.hasOverlap = hasOverlap;
function mapToObj(map) {
    return Object.fromEntries(map.entries());
}
exports.mapToObj = mapToObj;
function objToMap(obj) {
    return new Map(Object.entries(obj));
}
exports.objToMap = objToMap;
function mapEntries(obj, cb) {
    const res = {};
    Object.keys(obj).forEach(key => {
        res[key] = cb(obj[key]);
    });
    return res;
}
exports.mapEntries = mapEntries;
exports.enumify = (x) => x;
function capitalizeWord(word) {
    return word.trim().replace(/^\w/, c => c.toUpperCase());
}
exports.capitalizeWord = capitalizeWord;
function capitalize(str) {
    return str
        .split(" ")
        .map(w => capitalizeWord(w))
        .join(" ");
}
exports.capitalize = capitalize;
//# sourceMappingURL=misc.js.map