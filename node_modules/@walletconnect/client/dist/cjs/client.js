"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const tslib_1 = require("tslib");
const events_1 = require("events");
const pino_1 = tslib_1.__importDefault(require("pino"));
const keyvaluestorage_1 = tslib_1.__importDefault(require("keyvaluestorage"));
const types_1 = require("@walletconnect/types");
const utils_1 = require("@walletconnect/utils");
const logger_1 = require("@walletconnect/logger");
const controllers_1 = require("./controllers");
const constants_1 = require("./constants");
const crypto_1 = require("./controllers/crypto");
class Client extends types_1.IClient {
    constructor(opts) {
        super(opts);
        this.protocol = "wc";
        this.version = 2;
        this.events = new events_1.EventEmitter();
        this.context = constants_1.CLIENT_CONTEXT;
        const logger = typeof (opts === null || opts === void 0 ? void 0 : opts.logger) !== "undefined" && typeof (opts === null || opts === void 0 ? void 0 : opts.logger) !== "string"
            ? opts.logger
            : pino_1.default(logger_1.getDefaultLoggerOptions({ level: (opts === null || opts === void 0 ? void 0 : opts.logger) || "error" }));
        this.context = (opts === null || opts === void 0 ? void 0 : opts.name) || this.context;
        this.controller = (opts === null || opts === void 0 ? void 0 : opts.controller) || false;
        this.metadata = (opts === null || opts === void 0 ? void 0 : opts.metadata) || utils_1.getAppMetadata();
        const storage = (opts === null || opts === void 0 ? void 0 : opts.storage) || new keyvaluestorage_1.default(Object.assign(Object.assign({}, constants_1.CLIENT_STORAGE_OPTIONS), opts === null || opts === void 0 ? void 0 : opts.storageOptions));
        this.logger = logger_1.generateChildLogger(logger, this.context);
        this.crypto = new crypto_1.Crypto(this, (opts === null || opts === void 0 ? void 0 : opts.keychain) || new crypto_1.KeyChain(this, storage));
        this.relayer = new controllers_1.Relayer(this, this.logger, opts === null || opts === void 0 ? void 0 : opts.relayProvider);
        this.storage = storage;
        this.pairing = new controllers_1.Pairing(this, this.logger);
        this.session = new controllers_1.Session(this, this.logger);
    }
    static init(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const client = new Client(opts);
            yield client.initialize();
            return client;
        });
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    connect(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Connecting Application`);
            this.logger.trace({ type: "method", method: "connect", params });
            try {
                if (typeof params.pairing === undefined) {
                    this.logger.info("Connecing with existing pairing");
                }
                const pairing = typeof params.pairing === "undefined"
                    ? yield this.pairing.create()
                    : yield this.pairing.get(params.pairing.topic);
                this.logger.trace({ type: "method", method: "connect", pairing });
                const metadata = params.metadata || this.metadata;
                if (typeof metadata === "undefined") {
                    const error = utils_1.ERROR.MISSING_OR_INVALID.format({ name: "app metadata" });
                    this.logger.error(error.message);
                    throw new Error(error.message);
                }
                const session = yield this.session.create({
                    signal: { method: constants_1.SESSION_SIGNAL_METHOD_PAIRING, params: { topic: pairing.topic } },
                    relay: params.relay || { protocol: constants_1.RELAYER_DEFAULT_PROTOCOL },
                    metadata,
                    permissions: Object.assign(Object.assign({}, params.permissions), { notifications: constants_1.SESSION_EMPTY_PERMISSIONS.notifications }),
                });
                this.logger.debug(`Application Connection Successful`);
                this.logger.trace({ type: "method", method: "connect", session });
                return session;
            }
            catch (e) {
                this.logger.debug(`Application Connection Failure`);
                this.logger.error(e);
                throw e;
            }
        });
    }
    pair(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Pairing`);
            this.logger.trace({ type: "method", method: "pair", params });
            const proposal = formatPairingProposal(params.uri);
            const approved = proposal.proposer.controller !== this.controller;
            const reason = approved
                ? undefined
                : utils_1.ERROR.UNAUTHORIZED_MATCHING_CONTROLLER.format({ controller: this.controller });
            const pending = yield this.pairing.respond({ approved, proposal, reason });
            if (!utils_1.isPairingResponded(pending)) {
                const error = utils_1.ERROR.NO_MATCHING_RESPONSE.format({ context: "pairing" });
                this.logger.error(error.message);
                throw new Error(error.message);
            }
            if (utils_1.isPairingFailed(pending.outcome)) {
                this.logger.debug(`Pairing Failure`);
                this.logger.trace({ type: "method", method: "pair", outcome: pending.outcome });
                throw new Error(pending.outcome.reason.message);
            }
            this.logger.debug(`Pairing Success`);
            this.logger.trace({ type: "method", method: "pair", pending });
            return pending.outcome.topic;
        });
    }
    approve(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Approving Session Proposal`);
            this.logger.trace({ type: "method", method: "approve", params });
            if (typeof params.response === "undefined") {
                const error = utils_1.ERROR.MISSING_RESPONSE.format({ context: "session" });
                this.logger.error(error.message);
                throw new Error(error.message);
            }
            const state = params.response.state || constants_1.SESSION_EMPTY_STATE;
            const metadata = params.response.metadata || this.metadata;
            if (typeof metadata === "undefined") {
                const error = utils_1.ERROR.MISSING_OR_INVALID.format({ name: "app metadata" });
                this.logger.error(error.message);
                throw new Error(error.message);
            }
            const approved = params.proposal.proposer.controller !== this.controller;
            const reason = approved
                ? undefined
                : utils_1.ERROR.UNAUTHORIZED_MATCHING_CONTROLLER.format({ controller: this.controller });
            const pending = yield this.session.respond({
                approved,
                proposal: params.proposal,
                response: { state, metadata },
                reason,
            });
            if (!utils_1.isSessionResponded(pending)) {
                const error = utils_1.ERROR.NO_MATCHING_RESPONSE.format({ context: "session" });
                this.logger.error(error.message);
                throw new Error(error.message);
            }
            if (utils_1.isSessionFailed(pending.outcome)) {
                this.logger.debug(`Session Proposal Approval Failure`);
                this.logger.trace({ type: "method", method: "approve", outcome: pending.outcome });
                throw new Error(pending.outcome.reason.message);
            }
            this.logger.debug(`Session Proposal Approval Success`);
            this.logger.trace({ type: "method", method: "approve", pending });
            return this.session.get(pending.outcome.topic);
        });
    }
    reject(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Rejecting Session Proposal`);
            this.logger.trace({ type: "method", method: "reject", params });
            const pending = yield this.session.respond({
                approved: false,
                proposal: params.proposal,
                response: constants_1.SESSION_EMPTY_RESPONSE,
                reason: params.reason,
            });
            this.logger.debug(`Session Proposal Response Success`);
            this.logger.trace({ type: "method", method: "reject", pending });
        });
    }
    upgrade(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.session.upgrade(params);
        });
    }
    update(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.session.update(params);
        });
    }
    request(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.session.request(params);
        });
    }
    respond(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.session.send(params.topic, params.response);
        });
    }
    notify(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.session.notify(params);
        });
    }
    disconnect(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Disconnecting Application`);
            this.logger.trace({ type: "method", method: "disconnect", params });
            yield this.session.delete(params);
        });
    }
    onPairingRequest(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (request.method === constants_1.SESSION_JSONRPC.propose) {
                const proposal = request.params;
                if (proposal.proposer.controller === this.controller) {
                    const reason = utils_1.ERROR.UNAUTHORIZED_MATCHING_CONTROLLER.format({
                        controller: this.controller,
                    });
                    yield this.session.respond({
                        approved: false,
                        proposal,
                        response: constants_1.SESSION_EMPTY_RESPONSE,
                        reason,
                    });
                    return;
                }
                const eventName = constants_1.CLIENT_EVENTS.session.proposal;
                this.logger.info(`Emitting ${eventName}`);
                this.logger.debug({ type: "event", event: eventName, data: proposal });
                this.events.emit(eventName, proposal);
            }
        });
    }
    onPairingSettled(pairing) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (pairing.permissions.controller.publicKey === pairing.self.publicKey &&
                typeof pairing.state.metadata === "undefined") {
                yield this.pairing.update({ topic: pairing.topic, state: { metadata: this.metadata } });
            }
        });
    }
    initialize() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.trace(`Initialized`);
            try {
                yield this.crypto.init();
                yield this.relayer.init();
                yield this.pairing.init();
                yield this.session.init();
                this.setBeatInterval();
                this.registerEventListeners();
                this.logger.info(`Client Initilization Success`);
            }
            catch (e) {
                this.logger.info(`Client Initilization Failure`);
                this.logger.error(e);
                throw e;
            }
        });
    }
    setBeatInterval() {
        setInterval(() => this.events.emit(constants_1.CLIENT_EVENTS.beat), constants_1.CLIENT_BEAT_INTERVAL);
    }
    registerEventListeners() {
        this.pairing.on(constants_1.PAIRING_EVENTS.proposed, (pending) => {
            const eventName = constants_1.CLIENT_EVENTS.pairing.proposal;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: pending.proposal });
            this.events.emit(eventName, pending.proposal);
        });
        this.pairing.on(constants_1.PAIRING_EVENTS.settled, (pairing) => {
            const eventName = constants_1.CLIENT_EVENTS.pairing.created;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: pairing });
            this.events.emit(eventName, pairing);
            this.onPairingSettled(pairing);
        });
        this.pairing.on(constants_1.PAIRING_EVENTS.updated, (pairing, update) => {
            const eventName = constants_1.CLIENT_EVENTS.pairing.updated;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: pairing, update });
            this.events.emit(eventName, pairing, update);
        });
        this.pairing.on(constants_1.PAIRING_EVENTS.deleted, (pairing, reason) => {
            const eventName = constants_1.CLIENT_EVENTS.pairing.deleted;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: pairing, reason });
            this.events.emit(eventName, pairing, reason);
        });
        this.pairing.on(constants_1.PAIRING_EVENTS.request, (requestEvent) => {
            this.onPairingRequest(requestEvent.request);
        });
        this.session.on(constants_1.SESSION_EVENTS.proposed, (pending) => {
            const eventName = constants_1.CLIENT_EVENTS.session.proposal;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: pending.proposal });
            this.events.emit(eventName, pending.proposal);
        });
        this.session.on(constants_1.SESSION_EVENTS.settled, (session) => {
            const eventName = constants_1.CLIENT_EVENTS.session.created;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: session });
            this.events.emit(eventName, session);
        });
        this.session.on(constants_1.SESSION_EVENTS.updated, (session, update) => {
            const eventName = constants_1.CLIENT_EVENTS.session.updated;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: session, update });
            this.events.emit(eventName, session, update);
        });
        this.session.on(constants_1.SESSION_EVENTS.deleted, (session, reason) => {
            const eventName = constants_1.CLIENT_EVENTS.session.deleted;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: session, reason });
            this.events.emit(eventName, session, reason);
        });
        this.session.on(constants_1.SESSION_EVENTS.request, (requestEvent) => {
            const eventName = constants_1.CLIENT_EVENTS.session.request;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: requestEvent });
            this.events.emit(eventName, requestEvent);
        });
        this.session.on(constants_1.SESSION_EVENTS.response, (responseEvent) => {
            const eventName = constants_1.CLIENT_EVENTS.session.response;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: responseEvent });
            this.events.emit(eventName, responseEvent);
        });
        this.session.on(constants_1.SESSION_EVENTS.notification, (notificationEvent) => {
            const eventName = constants_1.CLIENT_EVENTS.session.notification;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: notificationEvent });
            this.events.emit(eventName, notificationEvent);
        });
    }
}
exports.Client = Client;
function formatPairingProposal(uri) {
    const uriParams = utils_1.parseUri(uri);
    return {
        topic: uriParams.topic,
        relay: uriParams.relay,
        proposer: { publicKey: uriParams.publicKey, controller: uriParams.controller },
        signal: { method: constants_1.PAIRING_SIGNAL_METHOD_URI, params: { uri } },
        permissions: {
            jsonrpc: { methods: [constants_1.SESSION_JSONRPC.propose] },
            notifications: { types: [] },
        },
        ttl: constants_1.PAIRING_DEFAULT_TTL,
    };
}
//# sourceMappingURL=client.js.map