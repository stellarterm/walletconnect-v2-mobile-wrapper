"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Crypto = exports.KeyChain = void 0;
const tslib_1 = require("tslib");
const encoding = tslib_1.__importStar(require("@walletconnect/encoding"));
const utils_1 = require("@walletconnect/utils");
const constants_1 = require("../constants");
class KeyChain {
    constructor(client, storage) {
        this.client = client;
        this.storage = storage;
        this.keychain = new Map();
        this.context = constants_1.KEYCHAIN_CONTEXT;
        this.client = client;
        this.storage = storage;
    }
    init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.restore();
        });
    }
    has(tag, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.keychain.has(tag);
        });
    }
    set(tag, key, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.keychain.set(tag, key);
            yield this.persist();
        });
    }
    get(tag, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const key = this.keychain.get(tag);
            if (typeof key === "undefined") {
                throw new Error(utils_1.ERROR.NO_MATCHING_KEY.format({ tag }).message);
            }
            return key;
        });
    }
    del(tag, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.keychain.delete(tag);
            yield this.persist();
        });
    }
    getStorageKey() {
        const storageKeyPrefix = `${this.client.protocol}@${this.client.version}:${this.client.context}`;
        return `${storageKeyPrefix}//${this.context}`;
    }
    restore() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const persisted = yield this.storage.getItem(this.getStorageKey());
            if (typeof persisted !== "undefined") {
                this.keychain = utils_1.objToMap(persisted);
            }
        });
    }
    persist() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.storage.setItem(this.getStorageKey(), utils_1.mapToObj(this.keychain));
        });
    }
}
exports.KeyChain = KeyChain;
class Crypto {
    constructor(client, keychain) {
        this.client = client;
        this.keychain = keychain;
        this.context = constants_1.CRYPTO_CONTEXT;
        this.client = client;
        this.keychain = keychain;
    }
    init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.keychain.init();
        });
    }
    hasKeys(tag) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.keychain.has(tag);
        });
    }
    generateKeyPair() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const keyPair = utils_1.generateKeyPair();
            return this.setKeyPair(keyPair);
        });
    }
    generateSharedKey(self, peer, overrideTopic) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const keyPair = yield this.getKeyPair(self.publicKey);
            const sharedKey = utils_1.deriveSharedKey(keyPair.privateKey, peer.publicKey);
            return this.setEncryptionKeys({ sharedKey, publicKey: keyPair.publicKey }, overrideTopic);
        });
    }
    encrypt(topic, message) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { sharedKey, publicKey } = yield this.getEncryptionKeys(topic);
            const result = yield utils_1.encrypt({ message, sharedKey, publicKey });
            return result;
        });
    }
    decrypt(topic, encrypted) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { sharedKey } = yield this.getEncryptionKeys(topic);
            const result = yield utils_1.decrypt({ encrypted, sharedKey });
            return result;
        });
    }
    concatKeys(keyA, keyB) {
        return encoding.arrayToHex(encoding.concatArrays(encoding.hexToArray(keyA), encoding.hexToArray(keyB)));
    }
    splitKeys(keys) {
        const arr = encoding.hexToArray(keys);
        return [encoding.arrayToHex(arr.slice(0, 32)), encoding.arrayToHex(arr.slice(32, 64))];
    }
    setKeyPair(keyPair) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const keys = this.concatKeys(keyPair.publicKey, keyPair.privateKey);
            yield this.keychain.set(keyPair.publicKey, keys);
            return keyPair.publicKey;
        });
    }
    getKeyPair(publicKey) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const [_, privateKey] = this.splitKeys(yield this.keychain.get(publicKey));
            return { publicKey, privateKey };
        });
    }
    setEncryptionKeys(encryptionKeys, overrideTopic) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const topic = overrideTopic || (yield utils_1.sha256(encryptionKeys.sharedKey));
            const keys = this.concatKeys(encryptionKeys.sharedKey, encryptionKeys.publicKey);
            yield this.keychain.set(topic, keys);
            return topic;
        });
    }
    getEncryptionKeys(topic) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const [sharedKey, publicKey] = this.splitKeys(yield this.keychain.get(topic));
            return { sharedKey, publicKey };
        });
    }
}
exports.Crypto = Crypto;
//# sourceMappingURL=crypto.js.map