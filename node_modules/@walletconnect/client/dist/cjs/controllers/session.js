"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Session = void 0;
const tslib_1 = require("tslib");
const events_1 = require("events");
const logger_1 = require("@walletconnect/logger");
const types_1 = require("@walletconnect/types");
const utils_1 = require("@walletconnect/utils");
const subscription_1 = require("./subscription");
const history_1 = require("./history");
const constants_1 = require("../constants");
const engine_1 = require("./engine");
class Session extends types_1.ISession {
    constructor(client, logger) {
        super(client, logger);
        this.client = client;
        this.logger = logger;
        this.events = new events_1.EventEmitter();
        this.context = constants_1.SESSION_CONTEXT;
        this.config = {
            status: constants_1.SESSION_STATUS,
            events: constants_1.SESSION_EVENTS,
            jsonrpc: constants_1.SESSION_JSONRPC,
        };
        this.logger = logger_1.generateChildLogger(logger, this.context);
        this.pending = new subscription_1.Subscription(client, this.logger, this.config.status.pending);
        this.settled = new subscription_1.Subscription(client, this.logger, this.config.status.settled);
        this.history = new history_1.JsonRpcHistory(client, this.logger);
        this.engine = new engine_1.Engine(this);
    }
    init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.trace(`Initialized`);
            yield this.pending.init();
            yield this.settled.init();
            yield this.history.init();
        });
    }
    get(topic) {
        return this.settled.get(topic);
    }
    find(permissions) {
        return this.engine.find(permissions);
    }
    ping(topic, timeout) {
        return this.engine.ping(topic, timeout);
    }
    send(topic, payload, chainId) {
        return this.engine.send(topic, payload, chainId);
    }
    get length() {
        return this.settled.length;
    }
    get topics() {
        return this.settled.topics;
    }
    get values() {
        return this.settled.values.map(x => x.data);
    }
    create(params) {
        return this.engine.create(params);
    }
    respond(params) {
        return this.engine.respond(params);
    }
    upgrade(params) {
        return this.engine.upgrade(params);
    }
    update(params) {
        return this.engine.update(params);
    }
    request(params) {
        return this.engine.request(params);
    }
    delete(params) {
        return this.engine.delete(params);
    }
    notify(params) {
        return this.engine.notify(params);
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    mergeUpdate(topic, update) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const settled = yield this.settled.get(topic);
            const state = {
                accounts: ((_a = update.state) === null || _a === void 0 ? void 0 : _a.accounts) || settled.state.accounts,
            };
            return state;
        });
    }
    mergeUpgrade(topic, upgrade) {
        var _a, _b, _c, _d, _e;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const settled = yield this.settled.get(topic);
            const permissions = {
                jsonrpc: {
                    methods: [
                        ...settled.permissions.jsonrpc.methods,
                        ...(((_a = upgrade.permissions.jsonrpc) === null || _a === void 0 ? void 0 : _a.methods) || []),
                    ],
                },
                notifications: {
                    types: [
                        ...(_b = settled.permissions.notifications) === null || _b === void 0 ? void 0 : _b.types,
                        ...(((_c = upgrade.permissions.notifications) === null || _c === void 0 ? void 0 : _c.types) || []),
                    ],
                },
                blockchain: {
                    chains: [
                        ...(_d = settled.permissions.blockchain) === null || _d === void 0 ? void 0 : _d.chains,
                        ...(((_e = upgrade.permissions.blockchain) === null || _e === void 0 ? void 0 : _e.chains) || []),
                    ],
                },
                controller: settled.permissions.controller,
            };
            return permissions;
        });
    }
    validateRespond(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (typeof params === "undefined") {
                const error = utils_1.ERROR.MISSING_OR_INVALID.format({ name: "respond params" });
                this.logger.error(error.message);
                throw new Error(error.message);
            }
            const paramsValidation = utils_1.validateSessionRespondParams(params);
            if (utils_1.isValidationInvalid(paramsValidation)) {
                this.logger.error(paramsValidation.error.message);
                throw new Error(paramsValidation.error.message);
            }
        });
    }
    validateRequest(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (typeof params === "undefined") {
                const error = utils_1.ERROR.MISSING_OR_INVALID.format({ name: "request params" });
                this.logger.error(error.message);
                throw new Error(error.message);
            }
            const { topic, chainId } = params;
            const settled = yield this.settled.get(topic);
            if (chainId && !settled.permissions.blockchain.chains.includes(chainId)) {
                const error = utils_1.ERROR.UNAUTHORIZED_TARGET_CHAIN.format({ chainId });
                this.logger.error(error.message);
                throw new Error(error.message);
            }
        });
    }
    validatePropose(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (typeof params === "undefined") {
                const error = utils_1.ERROR.MISSING_OR_INVALID.format({ name: "propose params" });
                this.logger.error(error.message);
                throw new Error(error.message);
            }
            const paramsValidation = utils_1.validateSessionProposeParams(params);
            if (utils_1.isValidationInvalid(paramsValidation)) {
                this.logger.error(paramsValidation.error.message);
                throw new Error(paramsValidation.error.message);
            }
            if (params.signal.method !== constants_1.SESSION_SIGNAL_METHOD_PAIRING) {
                const error = utils_1.ERROR.UNSUPPORTED_SIGNAL.format({ context: this.context });
                this.logger.error(error.message);
                throw new Error(error.message);
            }
        });
    }
    getDefaultSignal(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const pairing = yield this.client.pairing.settled.get(params.topic);
            const signal = {
                method: constants_1.SESSION_SIGNAL_METHOD_PAIRING,
                params: { topic: pairing.topic },
            };
            return signal;
        });
    }
    getDefaultTTL() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return constants_1.SESSION_DEFAULT_TTL;
        });
    }
    getDefaultPermissions() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return {
                jsonrpc: {
                    methods: [],
                },
                notifications: {
                    types: [],
                },
                blockchain: {
                    chains: [],
                },
            };
        });
    }
}
exports.Session = Session;
//# sourceMappingURL=session.js.map