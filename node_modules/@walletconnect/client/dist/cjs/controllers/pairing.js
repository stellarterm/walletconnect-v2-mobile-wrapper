"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pairing = void 0;
const tslib_1 = require("tslib");
const events_1 = require("events");
const logger_1 = require("@walletconnect/logger");
const types_1 = require("@walletconnect/types");
const utils_1 = require("@walletconnect/utils");
const subscription_1 = require("./subscription");
const history_1 = require("./history");
const engine_1 = require("./engine");
const constants_1 = require("../constants");
class Pairing extends types_1.IPairing {
    constructor(client, logger) {
        super(client, logger);
        this.client = client;
        this.logger = logger;
        this.events = new events_1.EventEmitter();
        this.context = constants_1.PAIRING_CONTEXT;
        this.config = {
            status: constants_1.PAIRING_STATUS,
            events: constants_1.PAIRING_EVENTS,
            jsonrpc: constants_1.PAIRING_JSONRPC,
        };
        this.logger = logger_1.generateChildLogger(logger, this.context);
        this.pending = new subscription_1.Subscription(client, this.logger, this.config.status.pending);
        this.settled = new subscription_1.Subscription(client, this.logger, this.config.status.settled);
        this.history = new history_1.JsonRpcHistory(client, this.logger);
        this.engine = new engine_1.Engine(this);
    }
    init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.trace(`Initialized`);
            yield this.pending.init();
            yield this.settled.init();
            yield this.history.init();
        });
    }
    get(topic) {
        return this.settled.get(topic);
    }
    find(permissions) {
        return this.engine.find(permissions);
    }
    ping(topic, timeout) {
        return this.engine.ping(topic, timeout);
    }
    send(topic, payload) {
        return this.engine.send(topic, payload);
    }
    get length() {
        return this.settled.length;
    }
    get topics() {
        return this.settled.topics;
    }
    get values() {
        return this.settled.values.map(x => x.data);
    }
    create(params) {
        return this.engine.create(params);
    }
    respond(params) {
        return this.engine.respond(params);
    }
    upgrade(params) {
        return this.engine.upgrade(params);
    }
    update(params) {
        return this.engine.update(params);
    }
    request(params) {
        return this.engine.request(params);
    }
    delete(params) {
        return this.engine.delete(params);
    }
    notify(params) {
        return this.engine.notify(params);
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    mergeUpdate(topic, update) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const settled = yield this.settled.get(topic);
            const state = {
                metadata: update.state.metadata || settled.state.metadata,
            };
            return state;
        });
    }
    mergeUpgrade(topic, upgrade) {
        var _a, _b, _c;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const settled = yield this.settled.get(topic);
            const permissions = {
                jsonrpc: {
                    methods: [
                        ...settled.permissions.jsonrpc.methods,
                        ...(((_a = upgrade.permissions.jsonrpc) === null || _a === void 0 ? void 0 : _a.methods) || []),
                    ],
                },
                notifications: {
                    types: [
                        ...(_b = settled.permissions.notifications) === null || _b === void 0 ? void 0 : _b.types,
                        ...(((_c = upgrade.permissions.notifications) === null || _c === void 0 ? void 0 : _c.types) || []),
                    ],
                },
                controller: settled.permissions.controller,
            };
            return permissions;
        });
    }
    validateRespond(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
        });
    }
    validateRequest(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
        });
    }
    validatePropose(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
        });
    }
    getDefaultSignal({ topic, relay, proposer }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const uri = utils_1.formatUri({
                protocol: this.client.protocol,
                version: this.client.version,
                topic: topic,
                publicKey: proposer.publicKey,
                controller: proposer.controller,
                relay: relay,
            });
            const signal = {
                method: constants_1.PAIRING_SIGNAL_METHOD_URI,
                params: { uri },
            };
            return signal;
        });
    }
    getDefaultTTL() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return constants_1.PAIRING_DEFAULT_TTL;
        });
    }
    getDefaultPermissions() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const permissions = {
                jsonrpc: {
                    methods: [constants_1.SESSION_JSONRPC.propose],
                },
                notifications: {
                    types: [],
                },
            };
            return permissions;
        });
    }
}
exports.Pairing = Pairing;
//# sourceMappingURL=pairing.js.map