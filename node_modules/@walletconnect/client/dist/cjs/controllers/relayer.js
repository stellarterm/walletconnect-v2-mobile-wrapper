"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Relayer = void 0;
const tslib_1 = require("tslib");
const events_1 = require("events");
const logger_1 = require("@walletconnect/logger");
const types_1 = require("@walletconnect/types");
const relay_api_1 = require("@walletconnect/relay-api");
const utils_1 = require("@walletconnect/utils");
const encoding = tslib_1.__importStar(require("@walletconnect/encoding"));
const jsonrpc_utils_1 = require("@walletconnect/jsonrpc-utils");
const jsonrpc_provider_1 = require("@walletconnect/jsonrpc-provider");
const jsonrpc_ws_connection_1 = require("@walletconnect/jsonrpc-ws-connection");
const safe_json_1 = require("@walletconnect/safe-json");
const constants_1 = require("../constants");
class Relayer extends types_1.IRelayer {
    constructor(client, logger, provider) {
        super(client, logger);
        this.client = client;
        this.logger = logger;
        this.events = new events_1.EventEmitter();
        this.context = constants_1.RELAYER_CONTEXT;
        this.logger = logger_1.generateChildLogger(logger, this.context);
        this.provider = this.setProvider(provider);
        this.registerEventListeners();
    }
    get connected() {
        return this.provider.connection.connected;
    }
    init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.trace(`Initialized`);
            yield this.provider.connect();
        });
    }
    publish(topic, payload, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Publishing Payload`);
            this.logger.trace({ type: "method", method: "publish", params: { topic, payload, opts } });
            try {
                const protocol = (opts === null || opts === void 0 ? void 0 : opts.relay.protocol) || constants_1.RELAYER_DEFAULT_PROTOCOL;
                const msg = safe_json_1.safeJsonStringify(payload);
                const hasKeys = yield this.client.crypto.hasKeys(topic);
                const message = hasKeys
                    ? yield this.client.crypto.encrypt(topic, msg)
                    : encoding.utf8ToHex(msg);
                const jsonRpc = getRelayProtocolJsonRpc(protocol);
                const request = {
                    method: jsonRpc.publish,
                    params: {
                        topic,
                        message,
                        ttl: (opts === null || opts === void 0 ? void 0 : opts.ttl) || constants_1.RELAYER_DEFAULT_PUBLISH_TTL,
                    },
                };
                this.logger.debug(`Outgoing Relay Payload`);
                this.logger.trace({ type: "payload", direction: "outgoing", request });
                yield this.provider.request(request);
                this.logger.debug(`Successfully Published Payload`);
                this.logger.trace({ type: "method", method: "publish", request });
            }
            catch (e) {
                this.logger.debug(`Failed to Publish Payload`);
                this.logger.error(e);
                throw e;
            }
        });
    }
    subscribe(topic, listener, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Subscribing Topic`);
            this.logger.trace({ type: "method", method: "subscribe", params: { topic, opts } });
            try {
                const protocol = (opts === null || opts === void 0 ? void 0 : opts.relay.protocol) || constants_1.RELAYER_DEFAULT_PROTOCOL;
                const jsonRpc = getRelayProtocolJsonRpc(protocol);
                const request = {
                    method: jsonRpc.subscribe,
                    params: {
                        topic,
                    },
                };
                this.logger.debug(`Outgoing Relay Payload`);
                this.logger.trace({ type: "payload", direction: "outgoing", request });
                const id = yield this.provider.request(request);
                this.events.on(id, ({ message }) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const hasKeys = yield this.client.crypto.hasKeys(topic);
                    const payload = safe_json_1.safeJsonParse(hasKeys ? yield this.client.crypto.decrypt(topic, message) : encoding.hexToUtf8(message));
                    listener(payload);
                }));
                this.logger.debug(`Successfully Subscribed Topic`);
                this.logger.trace({ type: "method", method: "subscribe", request });
                return id;
            }
            catch (e) {
                this.logger.debug(`Failed to Subscribe Topic`);
                this.logger.error(e);
                throw e;
            }
        });
    }
    unsubscribe(topic, id, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Unsubscribing Topic`);
            this.logger.trace({ type: "method", method: "unsubscribe", params: { id, opts } });
            try {
                const protocol = (opts === null || opts === void 0 ? void 0 : opts.relay.protocol) || constants_1.RELAYER_DEFAULT_PROTOCOL;
                const jsonRpc = getRelayProtocolJsonRpc(protocol);
                const request = {
                    method: jsonRpc.unsubscribe,
                    params: {
                        topic,
                        id,
                    },
                };
                this.logger.debug(`Outgoing Relay Payload`);
                this.logger.trace({ type: "payload", direction: "outgoing", request });
                yield this.provider.request(request);
                this.events.removeAllListeners(id);
                this.logger.debug(`Successfully Unsubscribed Topic`);
                this.logger.trace({ type: "method", method: "unsubscribe", request });
            }
            catch (e) {
                this.logger.debug(`Failed to Unsubscribe Topic`);
                this.logger.error(e);
                throw e;
            }
        });
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    onPayload(payload) {
        this.logger.debug(`Incoming Relay Payload`);
        this.logger.trace({ type: "payload", direction: "incoming", payload });
        if (jsonrpc_utils_1.isJsonRpcRequest(payload)) {
            if (payload.method.endsWith("_subscription")) {
                const event = payload.params;
                this.events.emit(event.id, event.data);
                const response = jsonrpc_utils_1.formatJsonRpcResult(payload.id, true);
                this.provider.connection.send(response);
            }
        }
    }
    setProvider(provider) {
        this.logger.debug(`Setting Relay Provider`);
        this.logger.trace({ type: "method", method: "setProvider", provider: provider === null || provider === void 0 ? void 0 : provider.toString() });
        const rpcUrl = utils_1.formatRelayRpcUrl(this.client.protocol, this.client.version, typeof provider === "string" ? provider : constants_1.RELAYER_DEFAULT_RPC_URL);
        return typeof provider !== "string" && typeof provider !== "undefined"
            ? provider
            : new jsonrpc_provider_1.JsonRpcProvider(new jsonrpc_ws_connection_1.WsConnection(rpcUrl));
    }
    registerEventListeners() {
        this.provider.on("payload", (payload) => this.onPayload(payload));
        this.provider.on("connect", () => this.events.emit(constants_1.RELAYER_EVENTS.connect));
        this.provider.on("disconnect", () => {
            this.events.emit(constants_1.RELAYER_EVENTS.disconnect);
            this.provider.connect();
        });
        this.provider.on("error", e => this.events.emit(constants_1.RELAYER_EVENTS.error, e));
    }
}
exports.Relayer = Relayer;
function getRelayProtocolJsonRpc(protocol) {
    const jsonrpc = relay_api_1.RELAY_JSONRPC[protocol];
    if (typeof jsonrpc === "undefined") {
        throw new Error(`Relay Protocol not supported: ${protocol}`);
    }
    return jsonrpc;
}
//# sourceMappingURL=relayer.js.map