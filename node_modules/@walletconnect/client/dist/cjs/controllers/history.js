"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonRpcHistory = void 0;
const tslib_1 = require("tslib");
const events_1 = require("events");
const types_1 = require("@walletconnect/types");
const utils_1 = require("@walletconnect/utils");
const jsonrpc_utils_1 = require("@walletconnect/jsonrpc-utils");
const logger_1 = require("@walletconnect/logger");
const constants_1 = require("../constants");
class JsonRpcHistory extends types_1.IJsonRpcHistory {
    constructor(client, logger) {
        super(client, logger);
        this.client = client;
        this.logger = logger;
        this.records = new Map();
        this.events = new events_1.EventEmitter();
        this.context = constants_1.HISTORY_CONTEXT;
        this.cached = [];
        this.client;
        this.logger = logger_1.generateChildLogger(logger, this.context);
        this.registerEventListeners();
    }
    init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.trace(`Initialized`);
            yield this.restore();
        });
    }
    get size() {
        return this.records.size;
    }
    get keys() {
        return Array.from(this.records.keys());
    }
    get values() {
        return Array.from(this.records.values());
    }
    get pending() {
        const requests = [];
        this.values.forEach(record => {
            if (typeof record.response !== "undefined")
                return;
            const requestEvent = {
                topic: record.topic,
                request: jsonrpc_utils_1.formatJsonRpcRequest(record.request.method, record.request.params, record.id),
                chainId: record.chainId,
            };
            return requests.push(requestEvent);
        });
        return requests;
    }
    set(topic, request, chainId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.isEnabled();
            this.logger.debug(`Setting JSON-RPC request history record`);
            this.logger.trace({ type: "method", method: "set", topic, request, chainId });
            if (this.records.has(request.id)) {
                const error = utils_1.ERROR.RECORD_ALREADY_EXISTS.format({
                    context: this.getHistoryContext(),
                    id: request.id,
                });
                this.logger.error(error.message);
                throw new Error(error.message);
            }
            const record = {
                id: request.id,
                topic,
                request: { method: request.method, params: request.params || null },
                chainId,
            };
            this.records.set(record.id, record);
            this.events.emit(constants_1.HISTORY_EVENTS.created, record);
        });
    }
    update(topic, response) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.isEnabled();
            this.logger.debug(`Updating JSON-RPC response history record`);
            this.logger.trace({ type: "method", method: "update", topic, response });
            if (!this.records.has(response.id))
                return;
            const record = yield this.getRecord(response.id);
            if (record.topic !== topic)
                return;
            if (typeof record.response !== "undefined")
                return;
            record.response = jsonrpc_utils_1.isJsonRpcError(response)
                ? { error: response.error }
                : { result: response.result };
            this.records.set(record.id, record);
            this.events.emit(constants_1.HISTORY_EVENTS.updated, record);
        });
    }
    get(topic, id) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.isEnabled();
            this.logger.debug(`Getting record`);
            this.logger.trace({ type: "method", method: "get", topic, id });
            const record = yield this.getRecord(id);
            if (record.topic !== topic) {
                const error = utils_1.ERROR.MISMATCHED_TOPIC.format({
                    context: this.getHistoryContext(),
                    id,
                });
                this.logger.error(error.message);
                throw new Error(error.message);
            }
            return record;
        });
    }
    delete(topic, id) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.isEnabled();
            this.logger.debug(`Deleting record`);
            this.logger.trace({ type: "method", method: "delete", id });
            this.values.forEach((record) => {
                if (record.topic === topic) {
                    if (typeof id !== "undefined" && record.id !== id)
                        return;
                    this.records.delete(record.id);
                    this.events.emit(constants_1.HISTORY_EVENTS.deleted, record);
                }
            });
        });
    }
    exists(topic, id) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.isEnabled();
            if (!this.records.has(id))
                return false;
            const record = yield this.getRecord(id);
            return record.topic === topic;
        });
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    getNestedContext(length) {
        const nestedContext = logger_1.getLoggerContext(this.logger).split("/");
        return nestedContext.slice(nestedContext.length - length, nestedContext.length);
    }
    getHistoryContext() {
        return this.getNestedContext(2).join(" ");
    }
    getStorageKey() {
        const storageKeyPrefix = `${this.client.protocol}@${this.client.version}:${this.client.context}`;
        const recordContext = this.getNestedContext(2).join(":");
        return `${storageKeyPrefix}//${recordContext}`;
    }
    getRecord(id) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.isEnabled();
            const record = this.records.get(id);
            if (!record) {
                const error = utils_1.ERROR.NO_MATCHING_ID.format({
                    context: this.getHistoryContext(),
                    id,
                });
                this.logger.error(error.message);
                throw new Error(error.message);
            }
            return record;
        });
    }
    persist() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.client.storage.setItem(this.getStorageKey(), this.values);
            this.events.emit(constants_1.HISTORY_EVENTS.sync);
        });
    }
    restore() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const persisted = yield this.client.storage.getItem(this.getStorageKey());
                if (typeof persisted === "undefined")
                    return;
                if (!persisted.length)
                    return;
                if (this.records.size) {
                    const error = utils_1.ERROR.RESTORE_WILL_OVERRIDE.format({
                        context: this.getHistoryContext(),
                    });
                    this.logger.error(error.message);
                    throw new Error(error.message);
                }
                this.cached = persisted;
                yield Promise.all(this.cached.map((record) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    this.records.set(record.id, record);
                })));
                yield this.enable();
                this.logger.debug(`Successfully Restored records for ${this.getHistoryContext()}`);
                this.logger.trace({ type: "method", method: "restore", records: this.values });
            }
            catch (e) {
                this.logger.debug(`Failed to Restore records for ${this.getHistoryContext()}`);
                this.logger.error(e);
            }
        });
    }
    reset() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.disable();
            yield Promise.all(this.cached.map((record) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                this.records.set(record.id, record);
            })));
            yield this.enable();
        });
    }
    isEnabled() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.cached.length)
                return;
            return new Promise(resolve => {
                this.events.once(constants_1.HISTORY_EVENTS.enabled, () => resolve());
            });
        });
    }
    enable() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.cached = [];
            this.events.emit(constants_1.HISTORY_EVENTS.enabled);
        });
    }
    disable() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.cached.length) {
                this.cached = this.values;
            }
            this.events.emit(constants_1.HISTORY_EVENTS.disabled);
        });
    }
    registerEventListeners() {
        this.events.on(constants_1.HISTORY_EVENTS.created, (record) => {
            const eventName = constants_1.HISTORY_EVENTS.created;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, record });
            this.persist();
        });
        this.events.on(constants_1.HISTORY_EVENTS.updated, (record) => {
            const eventName = constants_1.HISTORY_EVENTS.updated;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, record });
            this.persist();
        });
        this.events.on(constants_1.HISTORY_EVENTS.deleted, (record) => {
            const eventName = constants_1.HISTORY_EVENTS.deleted;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, record });
            this.persist();
        });
    }
}
exports.JsonRpcHistory = JsonRpcHistory;
//# sourceMappingURL=history.js.map