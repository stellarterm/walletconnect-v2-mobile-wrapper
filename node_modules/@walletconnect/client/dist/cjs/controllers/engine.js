"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Engine = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@walletconnect/types");
const utils_1 = require("@walletconnect/utils");
const jsonrpc_utils_1 = require("@walletconnect/jsonrpc-utils");
const constants_1 = require("../constants");
class Engine extends types_1.IEngine {
    constructor(sequence) {
        super(sequence);
        this.sequence = sequence;
        this.registerEventListeners();
    }
    find(permissions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.sequence.values.filter((settled) => {
                var _a, _b, _c, _d, _e, _f;
                let isCompatible = false;
                if (((_a = settled.permissions) === null || _a === void 0 ? void 0 : _a.jsonrpc) && ((_b = permissions.jsonrpc) === null || _b === void 0 ? void 0 : _b.methods) &&
                    utils_1.hasOverlap(permissions.jsonrpc.methods, settled.permissions.jsonrpc.methods)) {
                    isCompatible = true;
                }
                if (((_c = settled.permissions) === null || _c === void 0 ? void 0 : _c.blockchain) && ((_d = permissions.blockchain) === null || _d === void 0 ? void 0 : _d.chains) &&
                    utils_1.hasOverlap(permissions.blockchain.chains, settled.permissions.blockchain.chains)) {
                    isCompatible = true;
                }
                if (((_e = settled.permissions) === null || _e === void 0 ? void 0 : _e.notifications) && ((_f = permissions.notifications) === null || _f === void 0 ? void 0 : _f.types) &&
                    utils_1.hasOverlap(permissions.notifications.types, settled.permissions.notifications.types)) {
                    isCompatible = true;
                }
                return isCompatible;
            });
        });
    }
    ping(topic, timeout) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const request = { method: this.sequence.config.jsonrpc.ping, params: {} };
            return this.request({ topic, request, timeout: timeout || constants_1.THIRTY_SECONDS * 1000 });
        });
    }
    send(topic, payload, chainId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const settled = yield this.sequence.settled.get(topic);
            if (jsonrpc_utils_1.isJsonRpcRequest(payload)) {
                if (!Object.values(this.sequence.config.jsonrpc).includes(payload.method)) {
                    yield this.isJsonRpcAuthorized(topic, settled.self, payload);
                    yield this.sequence.validateRequest({ topic, request: payload, chainId });
                    yield this.sequence.history.set(topic, payload, chainId);
                    const params = {
                        chainId,
                        request: { method: payload.method, params: payload.params },
                    };
                    if (!params.chainId)
                        delete params.chainId;
                    payload = jsonrpc_utils_1.formatJsonRpcRequest(this.sequence.config.jsonrpc.payload, params, payload.id);
                }
            }
            else {
                yield this.sequence.history.update(topic, payload);
            }
            yield this.sequence.client.relayer.publish(settled.topic, payload, {
                relay: settled.relay,
            });
        });
    }
    get length() {
        return this.sequence.settled.length;
    }
    get topics() {
        return this.sequence.settled.topics;
    }
    get values() {
        return this.sequence.settled.values.map(x => x.data);
    }
    create(params) {
        return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.sequence.logger.debug(`Create ${this.sequence.context}`);
            this.sequence.logger.trace({ type: "method", method: "create", params });
            const maxTimeout = (params === null || params === void 0 ? void 0 : params.timeout) || constants_1.FIVE_MINUTES * 1000;
            const timeout = setTimeout(() => {
                const error = utils_1.ERROR.SETTLE_TIMEOUT.format({
                    context: this.sequence.context,
                    timeout: maxTimeout,
                });
                this.sequence.logger.error(error.message);
                reject(error.message);
            }, maxTimeout);
            let pending;
            try {
                pending = yield this.propose(params);
            }
            catch (e) {
                clearTimeout(timeout);
                return reject(e);
            }
            this.sequence.pending.on(constants_1.SUBSCRIPTION_EVENTS.updated, (updatedEvent) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (pending.topic !== updatedEvent.data.topic)
                    return;
                if (utils_1.isSequenceResponded(updatedEvent.data)) {
                    const outcome = updatedEvent.data.outcome;
                    clearTimeout(timeout);
                    if (utils_1.isSequenceFailed(outcome)) {
                        try {
                            yield this.sequence.pending.delete(pending.topic, outcome.reason);
                        }
                        catch (e) {
                            return reject(e);
                        }
                        reject(new Error(outcome.reason.message));
                    }
                    else {
                        try {
                            const settled = yield this.sequence.settled.get(outcome.topic);
                            const reason = utils_1.ERROR.SETTLED.format({ context: this.sequence.context });
                            yield this.sequence.pending.delete(pending.topic, reason);
                            resolve(settled);
                        }
                        catch (e) {
                            return reject(e);
                        }
                    }
                }
            }));
        }));
    }
    respond(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.sequence.logger.debug(`Respond ${this.sequence.context}`);
            this.sequence.logger.trace({ type: "method", method: "respond", params });
            yield this.sequence.validateRespond(params);
            const { approved, proposal, response } = params;
            const { relay, ttl } = proposal;
            const self = {
                publicKey: yield this.sequence.client.crypto.generateKeyPair(),
                metadata: response === null || response === void 0 ? void 0 : response.metadata,
            };
            if (!self.metadata)
                delete self.metadata;
            if (approved) {
                try {
                    const responder = {
                        publicKey: self.publicKey,
                        metadata: response === null || response === void 0 ? void 0 : response.metadata,
                    };
                    if (!responder.metadata)
                        delete responder.metadata;
                    const expiry = Date.now() + proposal.ttl * 1000;
                    const state = (response === null || response === void 0 ? void 0 : response.state) || {};
                    const peer = {
                        publicKey: proposal.proposer.publicKey,
                        metadata: proposal.proposer.metadata,
                    };
                    if (!peer.metadata)
                        delete peer.metadata;
                    const controller = proposal.proposer.controller
                        ? { publicKey: peer.publicKey }
                        : { publicKey: self.publicKey };
                    const permissions = Object.assign(Object.assign({}, proposal.permissions), { controller });
                    const settled = yield this.settle({
                        relay,
                        self,
                        peer,
                        permissions,
                        state,
                        ttl,
                        expiry,
                    });
                    const outcome = {
                        topic: settled.topic,
                        relay,
                        state,
                        responder,
                        expiry,
                    };
                    const pending = {
                        status: this.sequence.config.status.responded,
                        topic: proposal.topic,
                        relay,
                        self,
                        proposal,
                        outcome,
                    };
                    yield this.sequence.pending.set(pending.topic, pending, { relay: pending.relay });
                    return pending;
                }
                catch (e) {
                    const reason = utils_1.ERROR.GENERIC.format({ message: e.message });
                    const outcome = { reason };
                    const pending = {
                        status: this.sequence.config.status.responded,
                        topic: proposal.topic,
                        relay,
                        self,
                        proposal,
                        outcome,
                    };
                    yield this.sequence.pending.set(pending.topic, pending, { relay: pending.relay });
                    return pending;
                }
            }
            else {
                const defaultReason = utils_1.ERROR.NOT_APPROVED.format({ context: this.sequence.context });
                const outcome = { reason: (params === null || params === void 0 ? void 0 : params.reason) || defaultReason };
                const pending = {
                    status: this.sequence.config.status.responded,
                    topic: proposal.topic,
                    relay,
                    self,
                    proposal,
                    outcome,
                };
                yield this.sequence.pending.set(pending.topic, pending, { relay: pending.relay });
                return pending;
            }
        });
    }
    update(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.sequence.logger.debug(`Update ${this.sequence.context}`);
            this.sequence.logger.trace({ type: "method", method: "update", params });
            const settled = yield this.sequence.settled.get(params.topic);
            const participant = { publicKey: settled.self.publicKey };
            const update = yield this.handleUpdate(params.topic, params, participant);
            const request = jsonrpc_utils_1.formatJsonRpcRequest(this.sequence.config.jsonrpc.update, update);
            yield this.send(settled.topic, request);
            return settled;
        });
    }
    upgrade(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.sequence.logger.debug(`Upgrade ${this.sequence.context}`);
            this.sequence.logger.trace({ type: "method", method: "upgrade", params });
            const settled = yield this.sequence.settled.get(params.topic);
            const participant = { publicKey: settled.self.publicKey };
            const upgrade = yield this.handleUpgrade(params.topic, params, participant);
            const request = jsonrpc_utils_1.formatJsonRpcRequest(this.sequence.config.jsonrpc.upgrade, upgrade);
            yield this.send(settled.topic, request);
            return settled;
        });
    }
    request(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    yield this.sequence.validateRequest(params);
                }
                catch (e) {
                    return reject(e);
                }
                const request = jsonrpc_utils_1.formatJsonRpcRequest(params.request.method, params.request.params);
                const maxTimeout = (params === null || params === void 0 ? void 0 : params.timeout) || constants_1.FIVE_MINUTES * 1000;
                const timeout = setTimeout(() => {
                    const error = utils_1.ERROR.JSONRPC_REQUEST_TIMEOUT.format({
                        method: request.method,
                        timeout: maxTimeout,
                    });
                    this.sequence.logger.error(error.message);
                    reject(error.message);
                }, maxTimeout);
                this.sequence.events.on(this.sequence.config.events.response, (responseEvent) => {
                    if (params.topic !== responseEvent.topic)
                        return;
                    const response = responseEvent.response;
                    if (response.id !== request.id)
                        return;
                    clearTimeout(timeout);
                    if (jsonrpc_utils_1.isJsonRpcError(response)) {
                        const errorMessage = response.error.message;
                        this.sequence.logger.error(errorMessage);
                        return reject(new Error(errorMessage));
                    }
                    return resolve(response.result);
                });
                try {
                    yield this.send(params.topic, request, params === null || params === void 0 ? void 0 : params.chainId);
                }
                catch (e) {
                    clearTimeout(timeout);
                    return reject(e);
                }
            }));
        });
    }
    delete(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.sequence.logger.debug(`Delete ${this.sequence.context}`);
            this.sequence.logger.trace({ type: "method", method: "delete", params });
            yield this.sequence.settled.delete(params.topic, params.reason);
        });
    }
    notify(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const settled = yield this.sequence.settled.get(params.topic);
            yield this.isNotificationAuthorized(params.topic, settled.self, params.type);
            const notification = { type: params.type, data: params.data };
            const request = jsonrpc_utils_1.formatJsonRpcRequest(this.sequence.config.jsonrpc.notification, notification);
            yield this.send(params.topic, request);
        });
    }
    propose(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.sequence.logger.debug(`Propose ${this.sequence.context}`);
            this.sequence.logger.trace({ type: "method", method: "propose", params });
            yield this.sequence.validatePropose(params);
            const relay = (params === null || params === void 0 ? void 0 : params.relay) || { protocol: constants_1.RELAYER_DEFAULT_PROTOCOL };
            const topic = utils_1.generateRandomBytes32();
            const self = {
                publicKey: yield this.sequence.client.crypto.generateKeyPair(),
                metadata: params === null || params === void 0 ? void 0 : params.metadata,
            };
            if (!self.metadata)
                delete self.metadata;
            const proposer = {
                publicKey: self.publicKey,
                controller: this.sequence.client.controller,
                metadata: self.metadata,
            };
            if (!proposer.metadata)
                delete proposer.metadata;
            const signal = (params === null || params === void 0 ? void 0 : params.signal) || (yield this.sequence.getDefaultSignal({ topic, relay, proposer }));
            const permissions = (params === null || params === void 0 ? void 0 : params.permissions) || (yield this.sequence.getDefaultPermissions());
            const ttl = (params === null || params === void 0 ? void 0 : params.ttl) || (yield this.sequence.getDefaultTTL());
            const proposal = {
                relay,
                topic,
                proposer,
                signal,
                permissions,
                ttl,
            };
            const pending = {
                status: this.sequence.config.status.proposed,
                topic: proposal.topic,
                relay: proposal.relay,
                self,
                proposal,
            };
            yield this.sequence.pending.set(pending.topic, pending, { relay });
            return pending;
        });
    }
    settle(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.sequence.logger.debug(`Settle ${this.sequence.context}`);
            this.sequence.logger.trace({ type: "method", method: "settle", params });
            const topic = yield this.sequence.client.crypto.generateSharedKey(params.self, params.peer);
            const settled = {
                topic,
                relay: params.relay,
                self: params.self,
                peer: params.peer,
                permissions: params.permissions,
                expiry: params.expiry,
                state: params.state,
            };
            yield this.sequence.settled.set(settled.topic, settled, {
                relay: settled.relay,
                expiry: settled.expiry,
            });
            return settled;
        });
    }
    onResponse(payloadEvent) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { topic, payload } = payloadEvent;
            this.sequence.logger.debug(`Receiving ${this.sequence.context} response`);
            this.sequence.logger.trace({ type: "method", method: "onResponse", topic, payload });
            const request = payload;
            const outcome = request.params;
            const pending = yield this.sequence.pending.get(topic);
            let error;
            if (!utils_1.isSequenceFailed(outcome)) {
                try {
                    const controller = pending.proposal.proposer.controller
                        ? { publicKey: pending.proposal.proposer.publicKey }
                        : { publicKey: outcome.responder.publicKey };
                    const peer = {
                        publicKey: outcome.responder.publicKey,
                        metadata: outcome.responder.metadata,
                    };
                    if (!peer.metadata)
                        delete peer.metadata;
                    const state = outcome.state || {};
                    const permissions = Object.assign(Object.assign({}, pending.proposal.permissions), { controller });
                    const settled = yield this.settle({
                        relay: pending.relay,
                        self: pending.self,
                        peer,
                        permissions,
                        ttl: pending.proposal.ttl,
                        expiry: outcome.expiry,
                        state,
                    });
                    yield this.sequence.pending.update(topic, {
                        status: this.sequence.config.status.responded,
                        outcome: {
                            topic: settled.topic,
                            relay: settled.relay,
                            responder: outcome.responder,
                            expiry: settled.expiry,
                            state: settled.state,
                        },
                    });
                }
                catch (e) {
                    this.sequence.logger.error(e);
                    error = utils_1.ERROR.GENERIC.format({ message: e.message });
                    yield this.sequence.pending.update(topic, {
                        status: this.sequence.config.status.responded,
                        outcome: { reason: error },
                    });
                }
                const response = typeof error === "undefined"
                    ? jsonrpc_utils_1.formatJsonRpcResult(request.id, true)
                    : jsonrpc_utils_1.formatJsonRpcError(request.id, error);
                yield this.sequence.client.relayer.publish(pending.topic, response, {
                    relay: pending.relay,
                });
            }
            else {
                this.sequence.logger.error(outcome.reason);
                yield this.sequence.pending.update(topic, {
                    status: this.sequence.config.status.responded,
                    outcome: { reason: outcome.reason },
                });
            }
        });
    }
    onAcknowledge(payloadEvent) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { topic, payload } = payloadEvent;
            this.sequence.logger.debug(`Receiving ${this.sequence.context} acknowledge`);
            this.sequence.logger.trace({ type: "method", method: "onAcknowledge", topic, payload });
            const response = payload;
            const pending = yield this.sequence.pending.get(topic);
            if (!utils_1.isSequenceResponded(pending))
                return;
            if (jsonrpc_utils_1.isJsonRpcError(response) && !utils_1.isSequenceFailed(pending.outcome)) {
                yield this.sequence.settled.delete(pending.outcome.topic, response.error);
            }
            const reason = utils_1.ERROR.RESPONSE_ACKNOWLEDGED.format({ context: this.sequence.context });
            yield this.sequence.pending.delete(topic, reason);
        });
    }
    onMessage(payloadEvent) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { topic, payload } = payloadEvent;
            this.sequence.logger.debug(`Receiving ${this.sequence.context} message`);
            this.sequence.logger.trace({ type: "method", method: "onMessage", topic, payload });
            if (jsonrpc_utils_1.isJsonRpcRequest(payload)) {
                const request = payload;
                const settled = yield this.sequence.settled.get(payloadEvent.topic);
                let error;
                switch (request.method) {
                    case this.sequence.config.jsonrpc.payload:
                        yield this.onPayload(payloadEvent);
                        break;
                    case this.sequence.config.jsonrpc.update:
                        yield this.onUpdate(payloadEvent);
                        break;
                    case this.sequence.config.jsonrpc.upgrade:
                        yield this.onUpgrade(payloadEvent);
                        break;
                    case this.sequence.config.jsonrpc.notification:
                        yield this.onNotification(payloadEvent);
                        break;
                    case this.sequence.config.jsonrpc.delete:
                        yield this.sequence.settled.delete(settled.topic, request.params.reason);
                        break;
                    case this.sequence.config.jsonrpc.ping:
                        yield this.send(settled.topic, jsonrpc_utils_1.formatJsonRpcResult(request.id, true));
                        break;
                    default:
                        error = utils_1.ERROR.UNKNOWN_JSONRPC_METHOD.format({ method: request.method });
                        this.sequence.logger.error(error.message);
                        yield this.send(settled.topic, jsonrpc_utils_1.formatJsonRpcError(request.id, error));
                        break;
                }
            }
            else {
                this.onPayloadEvent(payloadEvent);
            }
        });
    }
    onPayload(payloadEvent) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { topic, payload } = payloadEvent;
            if (jsonrpc_utils_1.isJsonRpcRequest(payload)) {
                const { id, params } = payload;
                const { chainId } = params;
                const request = jsonrpc_utils_1.formatJsonRpcRequest(params.request.method, params.request.params, id);
                const settled = yield this.sequence.settled.get(topic);
                yield this.isJsonRpcAuthorized(topic, settled.peer, request);
                yield this.sequence.validateRequest({ topic, request, chainId });
                const settledPayloadEvent = {
                    topic,
                    payload: request,
                    chainId,
                };
                this.sequence.logger.debug(`Receiving ${this.sequence.context} payload`);
                this.sequence.logger.trace(Object.assign({ type: "method", method: "onPayload" }, settledPayloadEvent));
                this.onPayloadEvent(settledPayloadEvent);
            }
            else {
                const settledPayloadEvent = {
                    topic,
                    payload,
                };
                this.sequence.logger.debug(`Receiving ${this.sequence.context} payload`);
                this.sequence.logger.trace(Object.assign({ type: "method", method: "onPayload" }, settledPayloadEvent));
                this.onPayloadEvent(settledPayloadEvent);
            }
        });
    }
    onUpdate(payloadEvent) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { topic, payload } = payloadEvent;
            this.sequence.logger.debug(`Receiving ${this.sequence.context} update`);
            this.sequence.logger.trace({ type: "method", method: "onUpdate", topic, payload });
            const request = payloadEvent.payload;
            const settled = yield this.sequence.settled.get(payloadEvent.topic);
            try {
                const participant = { publicKey: settled.peer.publicKey };
                yield this.handleUpdate(topic, request.params, participant);
                const response = jsonrpc_utils_1.formatJsonRpcResult(request.id, true);
                yield this.send(settled.topic, response);
            }
            catch (e) {
                this.sequence.logger.error(e);
                const response = jsonrpc_utils_1.formatJsonRpcError(request.id, e.message);
                yield this.send(settled.topic, response);
            }
        });
    }
    onUpgrade(payloadEvent) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { topic, payload } = payloadEvent;
            this.sequence.logger.debug(`Receiving ${this.sequence.context} upgrade`);
            this.sequence.logger.trace({ type: "method", method: "onUpgrade", topic, payload });
            const request = payloadEvent.payload;
            const settled = yield this.sequence.settled.get(payloadEvent.topic);
            try {
                const participant = { publicKey: settled.peer.publicKey };
                yield this.handleUpgrade(topic, request.params, participant);
                const response = jsonrpc_utils_1.formatJsonRpcResult(request.id, true);
                yield this.send(settled.topic, response);
            }
            catch (e) {
                this.sequence.logger.error(e);
                const response = jsonrpc_utils_1.formatJsonRpcError(request.id, e.message);
                yield this.send(settled.topic, response);
            }
        });
    }
    onNotification(event) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const notification = event.payload.params;
            const settled = yield this.sequence.settled.get(event.topic);
            yield this.isNotificationAuthorized(event.topic, settled.peer, notification.type);
            const notificationEvent = {
                topic: event.topic,
                type: notification.type,
                data: notification.data,
            };
            const eventName = this.sequence.config.events.notification;
            this.sequence.logger.info(`Emitting ${eventName}`);
            this.sequence.logger.debug({ type: "event", event: eventName, notificationEvent });
            this.sequence.events.emit(eventName, notificationEvent);
        });
    }
    handleUpdate(topic, update, participant) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (typeof update.state === "undefined") {
                const error = utils_1.ERROR.INVALID_UPDATE_REQUEST.format({ context: this.sequence.context });
                this.sequence.logger.error(error.message);
                throw new Error(error.message);
            }
            const settled = yield this.sequence.settled.get(topic);
            if (participant.publicKey !== settled.permissions.controller.publicKey) {
                const error = utils_1.ERROR.UNAUTHORIZED_UPDATE_REQUEST.format({
                    context: this.sequence.context,
                });
                this.sequence.logger.error(error.message);
                throw new Error(error.message);
            }
            settled.state = yield this.sequence.mergeUpdate(topic, update);
            yield this.sequence.settled.update(settled.topic, settled);
            return update;
        });
    }
    handleUpgrade(topic, upgrade, participant) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (typeof upgrade.permissions === "undefined") {
                const error = utils_1.ERROR.INVALID_UPGRADE_REQUEST.format({ context: this.sequence.context });
                this.sequence.logger.error(error.message);
                throw new Error(error.message);
            }
            const settled = yield this.sequence.settled.get(topic);
            if (participant.publicKey !== settled.permissions.controller.publicKey) {
                const error = utils_1.ERROR.UNAUTHORIZED_UPGRADE_REQUEST.format({
                    context: this.sequence.context,
                });
                this.sequence.logger.error(error.message);
                throw new Error(error.message);
            }
            settled.permissions = yield this.sequence.mergeUpgrade(topic, upgrade);
            yield this.sequence.settled.update(settled.topic, settled);
            return upgrade;
        });
    }
    isJsonRpcAuthorized(topic, participant, request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const settled = yield this.sequence.settled.get(topic);
            if (participant.publicKey === settled.permissions.controller.publicKey)
                return;
            if (!settled.permissions.jsonrpc.methods.includes(request.method)) {
                const error = utils_1.ERROR.UNAUTHORIZED_JSON_RPC_METHOD.format({
                    method: request.method,
                });
                this.sequence.logger.error(error.message);
                throw new Error(error.message);
            }
        });
    }
    isNotificationAuthorized(topic, participant, type) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const settled = yield this.sequence.settled.get(topic);
            if (participant.publicKey === settled.permissions.controller.publicKey)
                return;
            if (settled.self.publicKey !== settled.permissions.controller.publicKey &&
                !settled.permissions.notifications.types.includes(type)) {
                const error = utils_1.ERROR.UNAUTHORIZED_NOTIFICATION_TYPE.format({ type });
                this.sequence.logger.error(error.message);
                throw new Error(error.message);
            }
        });
    }
    shouldIgnorePayloadEvent(payloadEvent) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { topic, payload } = payloadEvent;
            if (!this.sequence.settled.subscriptions.has(topic))
                return true;
            let exists = false;
            try {
                exists = yield this.sequence.history.exists(topic, payload.id);
            }
            catch (e) {
            }
            return exists;
        });
    }
    onPayloadEvent(payloadEvent) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { topic, payload, chainId } = payloadEvent;
            if (jsonrpc_utils_1.isJsonRpcRequest(payload)) {
                if (yield this.shouldIgnorePayloadEvent(payloadEvent))
                    return;
                yield this.sequence.history.set(topic, payload, chainId);
            }
            else {
                yield this.sequence.history.update(topic, payload);
            }
            if (jsonrpc_utils_1.isJsonRpcRequest(payload)) {
                const requestEvent = { topic, request: payload, chainId };
                const eventName = this.sequence.config.events.request;
                this.sequence.logger.info(`Emitting ${eventName}`);
                this.sequence.logger.debug({ type: "event", event: eventName, data: requestEvent });
                this.sequence.events.emit(eventName, requestEvent);
            }
            else {
                const responseEvent = { topic, response: payload, chainId };
                const eventName = this.sequence.config.events.response;
                this.sequence.logger.info(`Emitting ${eventName}`);
                this.sequence.logger.debug({ type: "event", event: eventName, data: responseEvent });
                this.sequence.events.emit(eventName, responseEvent);
            }
        });
    }
    onPendingPayloadEvent(event) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (jsonrpc_utils_1.isJsonRpcRequest(event.payload)) {
                switch (event.payload.method) {
                    case this.sequence.config.jsonrpc.approve:
                    case this.sequence.config.jsonrpc.reject:
                        this.onResponse(event);
                        break;
                    default:
                        break;
                }
            }
            else {
                this.onAcknowledge(event);
            }
        });
    }
    onPendingStatusEvent(event) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const pending = event.data;
            if (utils_1.isSignalTypePairing(pending.proposal.signal)) {
                if (!(yield this.sequence.client.crypto.hasKeys(pending.proposal.topic))) {
                    const pairing = yield this.sequence.client.pairing.settled.get(pending.proposal.signal.params.topic);
                    yield this.sequence.client.crypto.generateSharedKey(pairing.self, pairing.peer, pending.proposal.topic);
                }
            }
            if (utils_1.isSequenceResponded(pending)) {
                const eventName = this.sequence.config.events.responded;
                this.sequence.logger.info(`Emitting ${eventName}`);
                this.sequence.logger.debug({ type: "event", event: eventName, data: pending });
                this.sequence.events.emit(eventName, pending);
                if (!utils_1.isSubscriptionUpdatedEvent(event)) {
                    const method = !utils_1.isSequenceFailed(pending.outcome)
                        ? this.sequence.config.jsonrpc.approve
                        : this.sequence.config.jsonrpc.reject;
                    const request = jsonrpc_utils_1.formatJsonRpcRequest(method, pending.outcome);
                    yield this.sequence.client.relayer.publish(pending.topic, request, {
                        relay: pending.relay,
                    });
                }
            }
            else {
                const eventName = this.sequence.config.events.proposed;
                this.sequence.logger.info(`Emitting ${eventName}`);
                this.sequence.logger.debug({ type: "event", event: eventName, data: pending });
                this.sequence.events.emit(eventName, pending);
                if (utils_1.isSignalTypePairing(pending.proposal.signal)) {
                    const request = jsonrpc_utils_1.formatJsonRpcRequest(this.sequence.config.jsonrpc.propose, pending.proposal);
                    yield this.sequence.client.pairing.send(pending.proposal.signal.params.topic, request);
                }
            }
        });
    }
    registerEventListeners() {
        this.sequence.pending.on(constants_1.SUBSCRIPTION_EVENTS.payload, (payloadEvent) => this.onPendingPayloadEvent(payloadEvent));
        this.sequence.pending.on(constants_1.SUBSCRIPTION_EVENTS.created, (createdEvent) => this.onPendingStatusEvent(createdEvent));
        this.sequence.pending.on(constants_1.SUBSCRIPTION_EVENTS.updated, (updatedEvent) => this.onPendingStatusEvent(updatedEvent));
        this.sequence.settled.on(constants_1.SUBSCRIPTION_EVENTS.payload, (payloadEvent) => this.onMessage(payloadEvent));
        this.sequence.settled.on(constants_1.SUBSCRIPTION_EVENTS.created, (createdEvent) => {
            const { data: settled } = createdEvent;
            const eventName = this.sequence.config.events.settled;
            this.sequence.logger.info(`Emitting ${eventName}`);
            this.sequence.logger.debug({ type: "event", event: eventName, data: settled });
            this.sequence.events.emit(eventName, settled);
        });
        this.sequence.settled.on(constants_1.SUBSCRIPTION_EVENTS.updated, (updatedEvent) => {
            const { data: settled, update } = updatedEvent;
            const eventName = this.sequence.config.events.updated;
            this.sequence.logger.info(`Emitting ${eventName}`);
            this.sequence.logger.debug({ type: "event", event: eventName, data: settled, update });
            this.sequence.events.emit(eventName, settled, update);
        });
        this.sequence.settled.on(constants_1.SUBSCRIPTION_EVENTS.deleted, (deletedEvent) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { data: settled, reason } = deletedEvent;
            const eventName = this.sequence.config.events.deleted;
            this.sequence.logger.info(`Emitting ${eventName}`);
            this.sequence.logger.debug({ type: "event", event: eventName, data: settled, reason });
            this.sequence.events.emit(eventName, settled, reason);
            const request = jsonrpc_utils_1.formatJsonRpcRequest(this.sequence.config.jsonrpc.delete, { reason });
            yield this.sequence.history.delete(settled.topic);
            yield this.sequence.client.relayer.publish(settled.topic, request, {
                relay: settled.relay,
            });
        }));
        this.sequence.settled.on(constants_1.SUBSCRIPTION_EVENTS.sync, () => this.sequence.events.emit(this.sequence.config.events.sync));
        this.sequence.settled.on(constants_1.SUBSCRIPTION_EVENTS.enabled, () => this.sequence.events.emit(this.sequence.config.events.enabled));
        this.sequence.settled.on(constants_1.SUBSCRIPTION_EVENTS.disabled, () => this.sequence.events.emit(this.sequence.config.events.disabled));
    }
}
exports.Engine = Engine;
//# sourceMappingURL=engine.js.map