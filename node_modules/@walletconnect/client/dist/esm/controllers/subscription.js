import { EventEmitter } from "events";
import { ISubscription, } from "@walletconnect/types";
import { ERROR } from "@walletconnect/utils";
import { CLIENT_BEAT_INTERVAL, CLIENT_EVENTS, RELAYER_EVENTS, SUBSCRIPTION_DEFAULT_TTL, SUBSCRIPTION_EVENTS, } from "../constants";
import { generateChildLogger, getLoggerContext } from "@walletconnect/logger";
export class Subscription extends ISubscription {
    constructor(client, logger, context) {
        super(client, logger, context);
        this.client = client;
        this.logger = logger;
        this.context = context;
        this.subscriptions = new Map();
        this.events = new EventEmitter();
        this.timeout = new Map();
        this.cached = [];
        this.logger = generateChildLogger(logger, this.context);
        this.registerEventListeners();
    }
    async init() {
        this.logger.trace(`Initialized`);
        await this.restore();
    }
    get length() {
        return this.subscriptions.size;
    }
    get topics() {
        return Array.from(this.subscriptions.keys());
    }
    get values() {
        return Array.from(this.subscriptions.values());
    }
    async set(topic, data, opts) {
        await this.isEnabled();
        if (this.subscriptions.has(topic)) {
            this.update(topic, data);
        }
        else {
            this.logger.debug(`Setting subscription`);
            this.logger.trace({ type: "method", method: "set", topic, data, opts });
            await this.subscribeAndSet(topic, data, opts);
            this.events.emit(SUBSCRIPTION_EVENTS.created, {
                topic,
                data,
            });
        }
    }
    async get(topic) {
        await this.isEnabled();
        this.logger.debug(`Getting subscription`);
        this.logger.trace({ type: "method", method: "get", topic });
        const subscription = await this.getSubscription(topic);
        return subscription.data;
    }
    async update(topic, update) {
        await this.isEnabled();
        this.logger.debug(`Updating subscription`);
        this.logger.trace({ type: "method", method: "update", topic, update });
        const subscription = await this.getSubscription(topic);
        const data = Object.assign(Object.assign({}, subscription.data), update);
        this.subscriptions.set(topic, Object.assign(Object.assign({}, subscription), { topic,
            data }));
        this.events.emit(SUBSCRIPTION_EVENTS.updated, {
            topic,
            data,
            update,
        });
    }
    async delete(topic, reason) {
        await this.isEnabled();
        this.logger.debug(`Deleting subscription`);
        this.logger.trace({ type: "method", method: "delete", topic, reason });
        const subscription = await this.getSubscription(topic);
        this.subscriptions.delete(topic);
        await this.client.relayer.unsubscribe(subscription.topic, subscription.id, {
            relay: subscription.relay,
        });
        this.events.emit(SUBSCRIPTION_EVENTS.deleted, {
            topic,
            data: subscription.data,
            reason,
        });
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    async onPayload(payloadEvent) {
        this.events.emit(SUBSCRIPTION_EVENTS.payload, payloadEvent);
    }
    getNestedContext(length) {
        const nestedContext = getLoggerContext(this.logger).split("/");
        return nestedContext.slice(nestedContext.length - length, nestedContext.length);
    }
    getSubscriptionContext() {
        return this.getNestedContext(2).join(" ");
    }
    getStorageKey() {
        const storageKeyPrefix = `${this.client.protocol}@${this.client.version}:${this.client.context}`;
        const subscriptionContext = this.getNestedContext(2).join(":");
        return `${storageKeyPrefix}//${subscriptionContext}`;
    }
    async getSubscription(topic) {
        await this.isEnabled();
        const subscription = this.subscriptions.get(topic);
        if (!subscription) {
            const error = ERROR.NO_MATCHING_TOPIC.format({
                context: this.getSubscriptionContext(),
                topic,
            });
            this.logger.error(error.message);
            throw new Error(error.message);
        }
        return subscription;
    }
    async subscribeAndSet(topic, data, opts) {
        const id = await this.client.relayer.subscribe(topic, (payload) => this.onPayload({ topic, payload }), opts);
        const expiry = opts.expiry || Date.now() + SUBSCRIPTION_DEFAULT_TTL * 1000;
        this.subscriptions.set(topic, Object.assign(Object.assign({ id, topic, data }, opts), { expiry }));
        this.setTimeout(topic, expiry);
    }
    setTimeout(topic, expiry) {
        if (this.timeout.has(topic))
            return;
        const ttl = expiry - Date.now();
        if (ttl <= 0) {
            this.onTimeout(topic);
            return;
        }
        if (ttl > CLIENT_BEAT_INTERVAL)
            return;
        const timeout = setTimeout(() => this.onTimeout(topic), ttl);
        this.timeout.set(topic, timeout);
    }
    deleteTimeout(topic) {
        if (!this.timeout.has(topic))
            return;
        const timeout = this.timeout.get(topic);
        if (typeof timeout === "undefined")
            return;
        clearTimeout(timeout);
    }
    resetTimeout() {
        this.timeout.forEach(timeout => clearTimeout(timeout));
        this.timeout.clear();
    }
    onTimeout(topic) {
        this.deleteTimeout(topic);
        this.delete(topic, ERROR.EXPIRED.format({ context: this.getSubscriptionContext() }));
    }
    checkSubscriptions() {
        this.subscriptions.forEach(subscription => this.setTimeout(subscription.topic, subscription.expiry));
    }
    async persist() {
        await this.client.storage.setItem(this.getStorageKey(), this.values);
        this.events.emit(SUBSCRIPTION_EVENTS.sync);
    }
    async restore() {
        try {
            const persisted = await this.client.storage.getItem(this.getStorageKey());
            if (typeof persisted === "undefined")
                return;
            if (!persisted.length)
                return;
            if (this.subscriptions.size) {
                const error = ERROR.RESTORE_WILL_OVERRIDE.format({
                    context: this.getSubscriptionContext(),
                });
                this.logger.error(error.message);
                throw new Error(error.message);
            }
            this.cached = persisted;
            await Promise.all(this.cached.map(async (subscription) => {
                const { topic, data } = subscription;
                const opts = {
                    relay: subscription.relay,
                    expiry: subscription.expiry,
                };
                await this.subscribeAndSet(topic, data, opts);
            }));
            await this.enable();
            this.logger.debug(`Successfully Restored subscriptions for ${this.getSubscriptionContext()}`);
            this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
        }
        catch (e) {
            this.logger.debug(`Failed to Restore subscriptions for ${this.getSubscriptionContext()}`);
            this.logger.error(e);
        }
    }
    async reset() {
        await this.disable();
        await Promise.all(this.cached.map(async (subscription) => {
            const { topic, data } = subscription;
            const opts = {
                relay: subscription.relay,
                expiry: subscription.expiry,
            };
            await this.subscribeAndSet(topic, data, opts);
        }));
        await this.enable();
    }
    async isEnabled() {
        if (!this.cached.length)
            return;
        return new Promise(resolve => {
            this.events.once(SUBSCRIPTION_EVENTS.enabled, () => resolve());
        });
    }
    async enable() {
        this.cached = [];
        this.events.emit(SUBSCRIPTION_EVENTS.enabled);
    }
    async disable() {
        if (!this.cached.length) {
            this.cached = this.values;
        }
        this.resetTimeout();
        this.events.emit(SUBSCRIPTION_EVENTS.disabled);
    }
    registerEventListeners() {
        this.client.on(CLIENT_EVENTS.beat, () => this.checkSubscriptions());
        this.client.relayer.on(RELAYER_EVENTS.connect, () => this.reset());
        this.events.on(SUBSCRIPTION_EVENTS.payload, (payloadEvent) => {
            const eventName = SUBSCRIPTION_EVENTS.payload;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: payloadEvent });
        });
        this.events.on(SUBSCRIPTION_EVENTS.created, (createdEvent) => {
            const eventName = SUBSCRIPTION_EVENTS.created;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: createdEvent });
            this.persist();
        });
        this.events.on(SUBSCRIPTION_EVENTS.updated, (updatedEvent) => {
            const eventName = SUBSCRIPTION_EVENTS.updated;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: updatedEvent });
            this.persist();
        });
        this.events.on(SUBSCRIPTION_EVENTS.deleted, (deletedEvent) => {
            const eventName = SUBSCRIPTION_EVENTS.deleted;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: deletedEvent });
            this.persist();
        });
    }
}
//# sourceMappingURL=subscription.js.map