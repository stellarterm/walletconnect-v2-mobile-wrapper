import { EventEmitter } from "events";
import { generateChildLogger } from "@walletconnect/logger";
import { ISession } from "@walletconnect/types";
import { validateSessionProposeParams, validateSessionRespondParams, isValidationInvalid, ERROR, } from "@walletconnect/utils";
import { Subscription } from "./subscription";
import { JsonRpcHistory } from "./history";
import { SESSION_CONTEXT, SESSION_EVENTS, SESSION_JSONRPC, SESSION_STATUS, SESSION_SIGNAL_METHOD_PAIRING, SESSION_DEFAULT_TTL, } from "../constants";
import { Engine } from "./engine";
export class Session extends ISession {
    constructor(client, logger) {
        super(client, logger);
        this.client = client;
        this.logger = logger;
        this.events = new EventEmitter();
        this.context = SESSION_CONTEXT;
        this.config = {
            status: SESSION_STATUS,
            events: SESSION_EVENTS,
            jsonrpc: SESSION_JSONRPC,
        };
        this.logger = generateChildLogger(logger, this.context);
        this.pending = new Subscription(client, this.logger, this.config.status.pending);
        this.settled = new Subscription(client, this.logger, this.config.status.settled);
        this.history = new JsonRpcHistory(client, this.logger);
        this.engine = new Engine(this);
    }
    async init() {
        this.logger.trace(`Initialized`);
        await this.pending.init();
        await this.settled.init();
        await this.history.init();
    }
    get(topic) {
        return this.settled.get(topic);
    }
    find(permissions) {
        return this.engine.find(permissions);
    }
    ping(topic, timeout) {
        return this.engine.ping(topic, timeout);
    }
    send(topic, payload, chainId) {
        return this.engine.send(topic, payload, chainId);
    }
    get length() {
        return this.settled.length;
    }
    get topics() {
        return this.settled.topics;
    }
    get values() {
        return this.settled.values.map(x => x.data);
    }
    create(params) {
        return this.engine.create(params);
    }
    respond(params) {
        return this.engine.respond(params);
    }
    upgrade(params) {
        return this.engine.upgrade(params);
    }
    update(params) {
        return this.engine.update(params);
    }
    request(params) {
        return this.engine.request(params);
    }
    delete(params) {
        return this.engine.delete(params);
    }
    notify(params) {
        return this.engine.notify(params);
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    async mergeUpdate(topic, update) {
        var _a;
        const settled = await this.settled.get(topic);
        const state = {
            accounts: ((_a = update.state) === null || _a === void 0 ? void 0 : _a.accounts) || settled.state.accounts,
        };
        return state;
    }
    async mergeUpgrade(topic, upgrade) {
        var _a, _b, _c, _d, _e;
        const settled = await this.settled.get(topic);
        const permissions = {
            jsonrpc: {
                methods: [
                    ...settled.permissions.jsonrpc.methods,
                    ...(((_a = upgrade.permissions.jsonrpc) === null || _a === void 0 ? void 0 : _a.methods) || []),
                ],
            },
            notifications: {
                types: [
                    ...(_b = settled.permissions.notifications) === null || _b === void 0 ? void 0 : _b.types,
                    ...(((_c = upgrade.permissions.notifications) === null || _c === void 0 ? void 0 : _c.types) || []),
                ],
            },
            blockchain: {
                chains: [
                    ...(_d = settled.permissions.blockchain) === null || _d === void 0 ? void 0 : _d.chains,
                    ...(((_e = upgrade.permissions.blockchain) === null || _e === void 0 ? void 0 : _e.chains) || []),
                ],
            },
            controller: settled.permissions.controller,
        };
        return permissions;
    }
    async validateRespond(params) {
        if (typeof params === "undefined") {
            const error = ERROR.MISSING_OR_INVALID.format({ name: "respond params" });
            this.logger.error(error.message);
            throw new Error(error.message);
        }
        const paramsValidation = validateSessionRespondParams(params);
        if (isValidationInvalid(paramsValidation)) {
            this.logger.error(paramsValidation.error.message);
            throw new Error(paramsValidation.error.message);
        }
    }
    async validateRequest(params) {
        if (typeof params === "undefined") {
            const error = ERROR.MISSING_OR_INVALID.format({ name: "request params" });
            this.logger.error(error.message);
            throw new Error(error.message);
        }
        const { topic, chainId } = params;
        const settled = await this.settled.get(topic);
        if (chainId && !settled.permissions.blockchain.chains.includes(chainId)) {
            const error = ERROR.UNAUTHORIZED_TARGET_CHAIN.format({ chainId });
            this.logger.error(error.message);
            throw new Error(error.message);
        }
    }
    async validatePropose(params) {
        if (typeof params === "undefined") {
            const error = ERROR.MISSING_OR_INVALID.format({ name: "propose params" });
            this.logger.error(error.message);
            throw new Error(error.message);
        }
        const paramsValidation = validateSessionProposeParams(params);
        if (isValidationInvalid(paramsValidation)) {
            this.logger.error(paramsValidation.error.message);
            throw new Error(paramsValidation.error.message);
        }
        if (params.signal.method !== SESSION_SIGNAL_METHOD_PAIRING) {
            const error = ERROR.UNSUPPORTED_SIGNAL.format({ context: this.context });
            this.logger.error(error.message);
            throw new Error(error.message);
        }
    }
    async getDefaultSignal(params) {
        const pairing = await this.client.pairing.settled.get(params.topic);
        const signal = {
            method: SESSION_SIGNAL_METHOD_PAIRING,
            params: { topic: pairing.topic },
        };
        return signal;
    }
    async getDefaultTTL() {
        return SESSION_DEFAULT_TTL;
    }
    async getDefaultPermissions() {
        return {
            jsonrpc: {
                methods: [],
            },
            notifications: {
                types: [],
            },
            blockchain: {
                chains: [],
            },
        };
    }
}
//# sourceMappingURL=session.js.map