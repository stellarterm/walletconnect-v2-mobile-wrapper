import { EventEmitter } from "events";
import { generateChildLogger } from "@walletconnect/logger";
import { IPairing } from "@walletconnect/types";
import { formatUri } from "@walletconnect/utils";
import { Subscription } from "./subscription";
import { JsonRpcHistory } from "./history";
import { Engine } from "./engine";
import { PAIRING_CONTEXT, PAIRING_EVENTS, PAIRING_JSONRPC, PAIRING_STATUS, PAIRING_SIGNAL_METHOD_URI, SESSION_JSONRPC, PAIRING_DEFAULT_TTL, } from "../constants";
export class Pairing extends IPairing {
    constructor(client, logger) {
        super(client, logger);
        this.client = client;
        this.logger = logger;
        this.events = new EventEmitter();
        this.context = PAIRING_CONTEXT;
        this.config = {
            status: PAIRING_STATUS,
            events: PAIRING_EVENTS,
            jsonrpc: PAIRING_JSONRPC,
        };
        this.logger = generateChildLogger(logger, this.context);
        this.pending = new Subscription(client, this.logger, this.config.status.pending);
        this.settled = new Subscription(client, this.logger, this.config.status.settled);
        this.history = new JsonRpcHistory(client, this.logger);
        this.engine = new Engine(this);
    }
    async init() {
        this.logger.trace(`Initialized`);
        await this.pending.init();
        await this.settled.init();
        await this.history.init();
    }
    get(topic) {
        return this.settled.get(topic);
    }
    find(permissions) {
        return this.engine.find(permissions);
    }
    ping(topic, timeout) {
        return this.engine.ping(topic, timeout);
    }
    send(topic, payload) {
        return this.engine.send(topic, payload);
    }
    get length() {
        return this.settled.length;
    }
    get topics() {
        return this.settled.topics;
    }
    get values() {
        return this.settled.values.map(x => x.data);
    }
    create(params) {
        return this.engine.create(params);
    }
    respond(params) {
        return this.engine.respond(params);
    }
    upgrade(params) {
        return this.engine.upgrade(params);
    }
    update(params) {
        return this.engine.update(params);
    }
    request(params) {
        return this.engine.request(params);
    }
    delete(params) {
        return this.engine.delete(params);
    }
    notify(params) {
        return this.engine.notify(params);
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    async mergeUpdate(topic, update) {
        const settled = await this.settled.get(topic);
        const state = {
            metadata: update.state.metadata || settled.state.metadata,
        };
        return state;
    }
    async mergeUpgrade(topic, upgrade) {
        var _a, _b, _c;
        const settled = await this.settled.get(topic);
        const permissions = {
            jsonrpc: {
                methods: [
                    ...settled.permissions.jsonrpc.methods,
                    ...(((_a = upgrade.permissions.jsonrpc) === null || _a === void 0 ? void 0 : _a.methods) || []),
                ],
            },
            notifications: {
                types: [
                    ...(_b = settled.permissions.notifications) === null || _b === void 0 ? void 0 : _b.types,
                    ...(((_c = upgrade.permissions.notifications) === null || _c === void 0 ? void 0 : _c.types) || []),
                ],
            },
            controller: settled.permissions.controller,
        };
        return permissions;
    }
    async validateRespond(params) {
    }
    async validateRequest(params) {
    }
    async validatePropose(params) {
    }
    async getDefaultSignal({ topic, relay, proposer }) {
        const uri = formatUri({
            protocol: this.client.protocol,
            version: this.client.version,
            topic: topic,
            publicKey: proposer.publicKey,
            controller: proposer.controller,
            relay: relay,
        });
        const signal = {
            method: PAIRING_SIGNAL_METHOD_URI,
            params: { uri },
        };
        return signal;
    }
    async getDefaultTTL() {
        return PAIRING_DEFAULT_TTL;
    }
    async getDefaultPermissions() {
        const permissions = {
            jsonrpc: {
                methods: [SESSION_JSONRPC.propose],
            },
            notifications: {
                types: [],
            },
        };
        return permissions;
    }
}
//# sourceMappingURL=pairing.js.map