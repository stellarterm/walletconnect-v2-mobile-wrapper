import { EventEmitter } from "events";
import { generateChildLogger } from "@walletconnect/logger";
import { IRelayer } from "@walletconnect/types";
import { RELAY_JSONRPC } from "@walletconnect/relay-api";
import { formatRelayRpcUrl } from "@walletconnect/utils";
import * as encoding from "@walletconnect/encoding";
import { isJsonRpcRequest, formatJsonRpcResult, } from "@walletconnect/jsonrpc-utils";
import { JsonRpcProvider } from "@walletconnect/jsonrpc-provider";
import { WsConnection } from "@walletconnect/jsonrpc-ws-connection";
import { safeJsonParse, safeJsonStringify } from "@walletconnect/safe-json";
import { RELAYER_CONTEXT, RELAYER_DEFAULT_PROTOCOL, RELAYER_DEFAULT_RPC_URL, RELAYER_DEFAULT_PUBLISH_TTL, RELAYER_EVENTS, } from "../constants";
export class Relayer extends IRelayer {
    constructor(client, logger, provider) {
        super(client, logger);
        this.client = client;
        this.logger = logger;
        this.events = new EventEmitter();
        this.context = RELAYER_CONTEXT;
        this.logger = generateChildLogger(logger, this.context);
        this.provider = this.setProvider(provider);
        this.registerEventListeners();
    }
    get connected() {
        return this.provider.connection.connected;
    }
    async init() {
        this.logger.trace(`Initialized`);
        await this.provider.connect();
    }
    async publish(topic, payload, opts) {
        this.logger.debug(`Publishing Payload`);
        this.logger.trace({ type: "method", method: "publish", params: { topic, payload, opts } });
        try {
            const protocol = (opts === null || opts === void 0 ? void 0 : opts.relay.protocol) || RELAYER_DEFAULT_PROTOCOL;
            const msg = safeJsonStringify(payload);
            const hasKeys = await this.client.crypto.hasKeys(topic);
            const message = hasKeys
                ? await this.client.crypto.encrypt(topic, msg)
                : encoding.utf8ToHex(msg);
            const jsonRpc = getRelayProtocolJsonRpc(protocol);
            const request = {
                method: jsonRpc.publish,
                params: {
                    topic,
                    message,
                    ttl: (opts === null || opts === void 0 ? void 0 : opts.ttl) || RELAYER_DEFAULT_PUBLISH_TTL,
                },
            };
            this.logger.debug(`Outgoing Relay Payload`);
            this.logger.trace({ type: "payload", direction: "outgoing", request });
            await this.provider.request(request);
            this.logger.debug(`Successfully Published Payload`);
            this.logger.trace({ type: "method", method: "publish", request });
        }
        catch (e) {
            this.logger.debug(`Failed to Publish Payload`);
            this.logger.error(e);
            throw e;
        }
    }
    async subscribe(topic, listener, opts) {
        this.logger.debug(`Subscribing Topic`);
        this.logger.trace({ type: "method", method: "subscribe", params: { topic, opts } });
        try {
            const protocol = (opts === null || opts === void 0 ? void 0 : opts.relay.protocol) || RELAYER_DEFAULT_PROTOCOL;
            const jsonRpc = getRelayProtocolJsonRpc(protocol);
            const request = {
                method: jsonRpc.subscribe,
                params: {
                    topic,
                },
            };
            this.logger.debug(`Outgoing Relay Payload`);
            this.logger.trace({ type: "payload", direction: "outgoing", request });
            const id = await this.provider.request(request);
            this.events.on(id, async ({ message }) => {
                const hasKeys = await this.client.crypto.hasKeys(topic);
                const payload = safeJsonParse(hasKeys ? await this.client.crypto.decrypt(topic, message) : encoding.hexToUtf8(message));
                listener(payload);
            });
            this.logger.debug(`Successfully Subscribed Topic`);
            this.logger.trace({ type: "method", method: "subscribe", request });
            return id;
        }
        catch (e) {
            this.logger.debug(`Failed to Subscribe Topic`);
            this.logger.error(e);
            throw e;
        }
    }
    async unsubscribe(topic, id, opts) {
        this.logger.debug(`Unsubscribing Topic`);
        this.logger.trace({ type: "method", method: "unsubscribe", params: { id, opts } });
        try {
            const protocol = (opts === null || opts === void 0 ? void 0 : opts.relay.protocol) || RELAYER_DEFAULT_PROTOCOL;
            const jsonRpc = getRelayProtocolJsonRpc(protocol);
            const request = {
                method: jsonRpc.unsubscribe,
                params: {
                    topic,
                    id,
                },
            };
            this.logger.debug(`Outgoing Relay Payload`);
            this.logger.trace({ type: "payload", direction: "outgoing", request });
            await this.provider.request(request);
            this.events.removeAllListeners(id);
            this.logger.debug(`Successfully Unsubscribed Topic`);
            this.logger.trace({ type: "method", method: "unsubscribe", request });
        }
        catch (e) {
            this.logger.debug(`Failed to Unsubscribe Topic`);
            this.logger.error(e);
            throw e;
        }
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    onPayload(payload) {
        this.logger.debug(`Incoming Relay Payload`);
        this.logger.trace({ type: "payload", direction: "incoming", payload });
        if (isJsonRpcRequest(payload)) {
            if (payload.method.endsWith("_subscription")) {
                const event = payload.params;
                this.events.emit(event.id, event.data);
                const response = formatJsonRpcResult(payload.id, true);
                this.provider.connection.send(response);
            }
        }
    }
    setProvider(provider) {
        this.logger.debug(`Setting Relay Provider`);
        this.logger.trace({ type: "method", method: "setProvider", provider: provider === null || provider === void 0 ? void 0 : provider.toString() });
        const rpcUrl = formatRelayRpcUrl(this.client.protocol, this.client.version, typeof provider === "string" ? provider : RELAYER_DEFAULT_RPC_URL);
        return typeof provider !== "string" && typeof provider !== "undefined"
            ? provider
            : new JsonRpcProvider(new WsConnection(rpcUrl));
    }
    registerEventListeners() {
        this.provider.on("payload", (payload) => this.onPayload(payload));
        this.provider.on("connect", () => this.events.emit(RELAYER_EVENTS.connect));
        this.provider.on("disconnect", () => {
            this.events.emit(RELAYER_EVENTS.disconnect);
            this.provider.connect();
        });
        this.provider.on("error", e => this.events.emit(RELAYER_EVENTS.error, e));
    }
}
function getRelayProtocolJsonRpc(protocol) {
    const jsonrpc = RELAY_JSONRPC[protocol];
    if (typeof jsonrpc === "undefined") {
        throw new Error(`Relay Protocol not supported: ${protocol}`);
    }
    return jsonrpc;
}
//# sourceMappingURL=relayer.js.map