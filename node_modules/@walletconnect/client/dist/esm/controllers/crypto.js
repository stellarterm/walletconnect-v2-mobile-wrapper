import * as encoding from "@walletconnect/encoding";
import { ERROR, mapToObj, objToMap, generateKeyPair, deriveSharedKey, encrypt, decrypt, sha256, } from "@walletconnect/utils";
import { CRYPTO_CONTEXT, KEYCHAIN_CONTEXT } from "../constants";
export class KeyChain {
    constructor(client, storage) {
        this.client = client;
        this.storage = storage;
        this.keychain = new Map();
        this.context = KEYCHAIN_CONTEXT;
        this.client = client;
        this.storage = storage;
    }
    async init() {
        await this.restore();
    }
    async has(tag, opts) {
        return this.keychain.has(tag);
    }
    async set(tag, key, opts) {
        this.keychain.set(tag, key);
        await this.persist();
    }
    async get(tag, opts) {
        const key = this.keychain.get(tag);
        if (typeof key === "undefined") {
            throw new Error(ERROR.NO_MATCHING_KEY.format({ tag }).message);
        }
        return key;
    }
    async del(tag, opts) {
        this.keychain.delete(tag);
        await this.persist();
    }
    getStorageKey() {
        const storageKeyPrefix = `${this.client.protocol}@${this.client.version}:${this.client.context}`;
        return `${storageKeyPrefix}//${this.context}`;
    }
    async restore() {
        const persisted = await this.storage.getItem(this.getStorageKey());
        if (typeof persisted !== "undefined") {
            this.keychain = objToMap(persisted);
        }
    }
    async persist() {
        await this.storage.setItem(this.getStorageKey(), mapToObj(this.keychain));
    }
}
export class Crypto {
    constructor(client, keychain) {
        this.client = client;
        this.keychain = keychain;
        this.context = CRYPTO_CONTEXT;
        this.client = client;
        this.keychain = keychain;
    }
    async init() {
        await this.keychain.init();
    }
    async hasKeys(tag) {
        return this.keychain.has(tag);
    }
    async generateKeyPair() {
        const keyPair = generateKeyPair();
        return this.setKeyPair(keyPair);
    }
    async generateSharedKey(self, peer, overrideTopic) {
        const keyPair = await this.getKeyPair(self.publicKey);
        const sharedKey = deriveSharedKey(keyPair.privateKey, peer.publicKey);
        return this.setEncryptionKeys({ sharedKey, publicKey: keyPair.publicKey }, overrideTopic);
    }
    async encrypt(topic, message) {
        const { sharedKey, publicKey } = await this.getEncryptionKeys(topic);
        const result = await encrypt({ message, sharedKey, publicKey });
        return result;
    }
    async decrypt(topic, encrypted) {
        const { sharedKey } = await this.getEncryptionKeys(topic);
        const result = await decrypt({ encrypted, sharedKey });
        return result;
    }
    concatKeys(keyA, keyB) {
        return encoding.arrayToHex(encoding.concatArrays(encoding.hexToArray(keyA), encoding.hexToArray(keyB)));
    }
    splitKeys(keys) {
        const arr = encoding.hexToArray(keys);
        return [encoding.arrayToHex(arr.slice(0, 32)), encoding.arrayToHex(arr.slice(32, 64))];
    }
    async setKeyPair(keyPair) {
        const keys = this.concatKeys(keyPair.publicKey, keyPair.privateKey);
        await this.keychain.set(keyPair.publicKey, keys);
        return keyPair.publicKey;
    }
    async getKeyPair(publicKey) {
        const [_, privateKey] = this.splitKeys(await this.keychain.get(publicKey));
        return { publicKey, privateKey };
    }
    async setEncryptionKeys(encryptionKeys, overrideTopic) {
        const topic = overrideTopic || (await sha256(encryptionKeys.sharedKey));
        const keys = this.concatKeys(encryptionKeys.sharedKey, encryptionKeys.publicKey);
        await this.keychain.set(topic, keys);
        return topic;
    }
    async getEncryptionKeys(topic) {
        const [sharedKey, publicKey] = this.splitKeys(await this.keychain.get(topic));
        return { sharedKey, publicKey };
    }
}
//# sourceMappingURL=crypto.js.map