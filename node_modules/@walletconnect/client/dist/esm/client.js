import { EventEmitter } from "events";
import pino from "pino";
import KeyValueStorage from "keyvaluestorage";
import { IClient, } from "@walletconnect/types";
import { isPairingFailed, isSessionFailed, parseUri, isPairingResponded, isSessionResponded, getAppMetadata, ERROR, } from "@walletconnect/utils";
import { generateChildLogger, getDefaultLoggerOptions } from "@walletconnect/logger";
import { Pairing, Session, Relayer } from "./controllers";
import { CLIENT_CONTEXT, CLIENT_BEAT_INTERVAL, CLIENT_EVENTS, CLIENT_STORAGE_OPTIONS, PAIRING_DEFAULT_TTL, PAIRING_EVENTS, PAIRING_SIGNAL_METHOD_URI, RELAYER_DEFAULT_PROTOCOL, SESSION_EMPTY_PERMISSIONS, SESSION_EMPTY_RESPONSE, SESSION_EMPTY_STATE, SESSION_EVENTS, SESSION_JSONRPC, SESSION_SIGNAL_METHOD_PAIRING, } from "./constants";
import { Crypto, KeyChain } from "./controllers/crypto";
export class Client extends IClient {
    constructor(opts) {
        super(opts);
        this.protocol = "wc";
        this.version = 2;
        this.events = new EventEmitter();
        this.context = CLIENT_CONTEXT;
        const logger = typeof (opts === null || opts === void 0 ? void 0 : opts.logger) !== "undefined" && typeof (opts === null || opts === void 0 ? void 0 : opts.logger) !== "string"
            ? opts.logger
            : pino(getDefaultLoggerOptions({ level: (opts === null || opts === void 0 ? void 0 : opts.logger) || "error" }));
        this.context = (opts === null || opts === void 0 ? void 0 : opts.name) || this.context;
        this.controller = (opts === null || opts === void 0 ? void 0 : opts.controller) || false;
        this.metadata = (opts === null || opts === void 0 ? void 0 : opts.metadata) || getAppMetadata();
        const storage = (opts === null || opts === void 0 ? void 0 : opts.storage) || new KeyValueStorage(Object.assign(Object.assign({}, CLIENT_STORAGE_OPTIONS), opts === null || opts === void 0 ? void 0 : opts.storageOptions));
        this.logger = generateChildLogger(logger, this.context);
        this.crypto = new Crypto(this, (opts === null || opts === void 0 ? void 0 : opts.keychain) || new KeyChain(this, storage));
        this.relayer = new Relayer(this, this.logger, opts === null || opts === void 0 ? void 0 : opts.relayProvider);
        this.storage = storage;
        this.pairing = new Pairing(this, this.logger);
        this.session = new Session(this, this.logger);
    }
    static async init(opts) {
        const client = new Client(opts);
        await client.initialize();
        return client;
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    async connect(params) {
        this.logger.debug(`Connecting Application`);
        this.logger.trace({ type: "method", method: "connect", params });
        try {
            if (typeof params.pairing === undefined) {
                this.logger.info("Connecing with existing pairing");
            }
            const pairing = typeof params.pairing === "undefined"
                ? await this.pairing.create()
                : await this.pairing.get(params.pairing.topic);
            this.logger.trace({ type: "method", method: "connect", pairing });
            const metadata = params.metadata || this.metadata;
            if (typeof metadata === "undefined") {
                const error = ERROR.MISSING_OR_INVALID.format({ name: "app metadata" });
                this.logger.error(error.message);
                throw new Error(error.message);
            }
            const session = await this.session.create({
                signal: { method: SESSION_SIGNAL_METHOD_PAIRING, params: { topic: pairing.topic } },
                relay: params.relay || { protocol: RELAYER_DEFAULT_PROTOCOL },
                metadata,
                permissions: Object.assign(Object.assign({}, params.permissions), { notifications: SESSION_EMPTY_PERMISSIONS.notifications }),
            });
            this.logger.debug(`Application Connection Successful`);
            this.logger.trace({ type: "method", method: "connect", session });
            return session;
        }
        catch (e) {
            this.logger.debug(`Application Connection Failure`);
            this.logger.error(e);
            throw e;
        }
    }
    async pair(params) {
        this.logger.debug(`Pairing`);
        this.logger.trace({ type: "method", method: "pair", params });
        const proposal = formatPairingProposal(params.uri);
        const approved = proposal.proposer.controller !== this.controller;
        const reason = approved
            ? undefined
            : ERROR.UNAUTHORIZED_MATCHING_CONTROLLER.format({ controller: this.controller });
        const pending = await this.pairing.respond({ approved, proposal, reason });
        if (!isPairingResponded(pending)) {
            const error = ERROR.NO_MATCHING_RESPONSE.format({ context: "pairing" });
            this.logger.error(error.message);
            throw new Error(error.message);
        }
        if (isPairingFailed(pending.outcome)) {
            this.logger.debug(`Pairing Failure`);
            this.logger.trace({ type: "method", method: "pair", outcome: pending.outcome });
            throw new Error(pending.outcome.reason.message);
        }
        this.logger.debug(`Pairing Success`);
        this.logger.trace({ type: "method", method: "pair", pending });
        return pending.outcome.topic;
    }
    async approve(params) {
        this.logger.debug(`Approving Session Proposal`);
        this.logger.trace({ type: "method", method: "approve", params });
        if (typeof params.response === "undefined") {
            const error = ERROR.MISSING_RESPONSE.format({ context: "session" });
            this.logger.error(error.message);
            throw new Error(error.message);
        }
        const state = params.response.state || SESSION_EMPTY_STATE;
        const metadata = params.response.metadata || this.metadata;
        if (typeof metadata === "undefined") {
            const error = ERROR.MISSING_OR_INVALID.format({ name: "app metadata" });
            this.logger.error(error.message);
            throw new Error(error.message);
        }
        const approved = params.proposal.proposer.controller !== this.controller;
        const reason = approved
            ? undefined
            : ERROR.UNAUTHORIZED_MATCHING_CONTROLLER.format({ controller: this.controller });
        const pending = await this.session.respond({
            approved,
            proposal: params.proposal,
            response: { state, metadata },
            reason,
        });
        if (!isSessionResponded(pending)) {
            const error = ERROR.NO_MATCHING_RESPONSE.format({ context: "session" });
            this.logger.error(error.message);
            throw new Error(error.message);
        }
        if (isSessionFailed(pending.outcome)) {
            this.logger.debug(`Session Proposal Approval Failure`);
            this.logger.trace({ type: "method", method: "approve", outcome: pending.outcome });
            throw new Error(pending.outcome.reason.message);
        }
        this.logger.debug(`Session Proposal Approval Success`);
        this.logger.trace({ type: "method", method: "approve", pending });
        return this.session.get(pending.outcome.topic);
    }
    async reject(params) {
        this.logger.debug(`Rejecting Session Proposal`);
        this.logger.trace({ type: "method", method: "reject", params });
        const pending = await this.session.respond({
            approved: false,
            proposal: params.proposal,
            response: SESSION_EMPTY_RESPONSE,
            reason: params.reason,
        });
        this.logger.debug(`Session Proposal Response Success`);
        this.logger.trace({ type: "method", method: "reject", pending });
    }
    async upgrade(params) {
        await this.session.upgrade(params);
    }
    async update(params) {
        await this.session.update(params);
    }
    async request(params) {
        return this.session.request(params);
    }
    async respond(params) {
        await this.session.send(params.topic, params.response);
    }
    async notify(params) {
        await this.session.notify(params);
    }
    async disconnect(params) {
        this.logger.debug(`Disconnecting Application`);
        this.logger.trace({ type: "method", method: "disconnect", params });
        await this.session.delete(params);
    }
    async onPairingRequest(request) {
        if (request.method === SESSION_JSONRPC.propose) {
            const proposal = request.params;
            if (proposal.proposer.controller === this.controller) {
                const reason = ERROR.UNAUTHORIZED_MATCHING_CONTROLLER.format({
                    controller: this.controller,
                });
                await this.session.respond({
                    approved: false,
                    proposal,
                    response: SESSION_EMPTY_RESPONSE,
                    reason,
                });
                return;
            }
            const eventName = CLIENT_EVENTS.session.proposal;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: proposal });
            this.events.emit(eventName, proposal);
        }
    }
    async onPairingSettled(pairing) {
        if (pairing.permissions.controller.publicKey === pairing.self.publicKey &&
            typeof pairing.state.metadata === "undefined") {
            await this.pairing.update({ topic: pairing.topic, state: { metadata: this.metadata } });
        }
    }
    async initialize() {
        this.logger.trace(`Initialized`);
        try {
            await this.crypto.init();
            await this.relayer.init();
            await this.pairing.init();
            await this.session.init();
            this.setBeatInterval();
            this.registerEventListeners();
            this.logger.info(`Client Initilization Success`);
        }
        catch (e) {
            this.logger.info(`Client Initilization Failure`);
            this.logger.error(e);
            throw e;
        }
    }
    setBeatInterval() {
        setInterval(() => this.events.emit(CLIENT_EVENTS.beat), CLIENT_BEAT_INTERVAL);
    }
    registerEventListeners() {
        this.pairing.on(PAIRING_EVENTS.proposed, (pending) => {
            const eventName = CLIENT_EVENTS.pairing.proposal;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: pending.proposal });
            this.events.emit(eventName, pending.proposal);
        });
        this.pairing.on(PAIRING_EVENTS.settled, (pairing) => {
            const eventName = CLIENT_EVENTS.pairing.created;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: pairing });
            this.events.emit(eventName, pairing);
            this.onPairingSettled(pairing);
        });
        this.pairing.on(PAIRING_EVENTS.updated, (pairing, update) => {
            const eventName = CLIENT_EVENTS.pairing.updated;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: pairing, update });
            this.events.emit(eventName, pairing, update);
        });
        this.pairing.on(PAIRING_EVENTS.deleted, (pairing, reason) => {
            const eventName = CLIENT_EVENTS.pairing.deleted;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: pairing, reason });
            this.events.emit(eventName, pairing, reason);
        });
        this.pairing.on(PAIRING_EVENTS.request, (requestEvent) => {
            this.onPairingRequest(requestEvent.request);
        });
        this.session.on(SESSION_EVENTS.proposed, (pending) => {
            const eventName = CLIENT_EVENTS.session.proposal;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: pending.proposal });
            this.events.emit(eventName, pending.proposal);
        });
        this.session.on(SESSION_EVENTS.settled, (session) => {
            const eventName = CLIENT_EVENTS.session.created;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: session });
            this.events.emit(eventName, session);
        });
        this.session.on(SESSION_EVENTS.updated, (session, update) => {
            const eventName = CLIENT_EVENTS.session.updated;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: session, update });
            this.events.emit(eventName, session, update);
        });
        this.session.on(SESSION_EVENTS.deleted, (session, reason) => {
            const eventName = CLIENT_EVENTS.session.deleted;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: session, reason });
            this.events.emit(eventName, session, reason);
        });
        this.session.on(SESSION_EVENTS.request, (requestEvent) => {
            const eventName = CLIENT_EVENTS.session.request;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: requestEvent });
            this.events.emit(eventName, requestEvent);
        });
        this.session.on(SESSION_EVENTS.response, (responseEvent) => {
            const eventName = CLIENT_EVENTS.session.response;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: responseEvent });
            this.events.emit(eventName, responseEvent);
        });
        this.session.on(SESSION_EVENTS.notification, (notificationEvent) => {
            const eventName = CLIENT_EVENTS.session.notification;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: notificationEvent });
            this.events.emit(eventName, notificationEvent);
        });
    }
}
function formatPairingProposal(uri) {
    const uriParams = parseUri(uri);
    return {
        topic: uriParams.topic,
        relay: uriParams.relay,
        proposer: { publicKey: uriParams.publicKey, controller: uriParams.controller },
        signal: { method: PAIRING_SIGNAL_METHOD_URI, params: { uri } },
        permissions: {
            jsonrpc: { methods: [SESSION_JSONRPC.propose] },
            notifications: { types: [] },
        },
        ttl: PAIRING_DEFAULT_TTL,
    };
}
//# sourceMappingURL=client.js.map