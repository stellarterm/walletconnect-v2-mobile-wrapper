import { IClient } from "./client";
export declare namespace CryptoTypes {
    interface Participant {
        publicKey: string;
    }
    interface KeyPair {
        privateKey: string;
        publicKey: string;
    }
    interface EncryptionKeys {
        sharedKey: string;
        publicKey: string;
        iv?: string;
    }
    interface EncryptParams extends EncryptionKeys {
        message: string;
    }
    interface DecryptParams {
        sharedKey: string;
        encrypted: string;
    }
}
export declare abstract class IKeyChain {
    abstract init(): Promise<void>;
    abstract has(tag: string, opts?: any): Promise<boolean>;
    abstract set(tag: string, key: string, opts?: any): Promise<void>;
    abstract get(tag: string, opts?: any): Promise<string>;
    abstract del(tag: string, opts?: any): Promise<void>;
}
export declare abstract class ICrypto {
    client: IClient;
    keychain: IKeyChain;
    abstract context: string;
    constructor(client: IClient, keychain: IKeyChain);
    abstract init(): Promise<void>;
    abstract hasKeys(tag: string): Promise<boolean>;
    abstract generateKeyPair(): Promise<string>;
    abstract generateSharedKey(self: CryptoTypes.Participant, peer: CryptoTypes.Participant, overrideTopic?: string): Promise<string>;
    abstract encrypt(topic: string, message: string): Promise<string>;
    abstract decrypt(topic: string, encrypted: string): Promise<string>;
}
//# sourceMappingURL=crypto.d.ts.map