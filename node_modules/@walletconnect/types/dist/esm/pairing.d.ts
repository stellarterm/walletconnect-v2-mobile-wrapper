import { SequenceTypes, ISequence } from "./sequence";
import { AppMetadata, SignalTypes } from "./misc";
import { IEngine } from "./engine";
export declare namespace PairingTypes {
    type Status = SequenceTypes.Status;
    type JsonRpc = SequenceTypes.JsonRpc;
    type Events = SequenceTypes.Events;
    type Config = SequenceTypes.Config<Events, JsonRpc, Status>;
    type Relay = SequenceTypes.Relay;
    type BasePermissions = Omit<SequenceTypes.BasePermissions, "blockchain">;
    type ProposedPermissions = Omit<SequenceTypes.ProposedPermissions, "blockchain">;
    type SettledPermissions = Omit<SequenceTypes.SettledPermissions, "blockchain">;
    type Permissions = Omit<SequenceTypes.Permissions, "blockchain">;
    type ProposeParams = SequenceTypes.ProposeParams;
    type CreateParams = SequenceTypes.CreateParams;
    type Signal = SignalTypes.Uri;
    type Participant = SequenceTypes.Participant;
    type ProposedPeer = SequenceTypes.ProposedPeer;
    type Proposal = SequenceTypes.Proposal<Signal, ProposedPeer, ProposedPermissions>;
    type ProposedStatus = SequenceTypes.ProposedStatus;
    type RespondedStatus = SequenceTypes.RespondedStatus;
    type PendingStatus = SequenceTypes.PendingStatus;
    type BasePending = SequenceTypes.BasePending<Participant, Proposal>;
    type ProposedPending = SequenceTypes.ProposedPending<Participant, Proposal>;
    type RespondedPending = SequenceTypes.RespondedPending<Participant, Proposal, State>;
    type Pending = SequenceTypes.Pending<Participant, Proposal, State>;
    type RespondParams = SequenceTypes.RespondParams<Proposal>;
    type SettleParams = SequenceTypes.SettleParams<State, Participant, Permissions>;
    type UpgradeParams = SequenceTypes.UpgradeParams<Permissions>;
    type UpdateParams = SequenceTypes.UpdateParams<State>;
    type RequestParams = SequenceTypes.RequestParams;
    type Upgrade = SequenceTypes.Upgrade<Permissions>;
    type Update = SequenceTypes.Update<State>;
    type Request = SequenceTypes.Request;
    type PayloadEvent = SequenceTypes.PayloadEvent;
    type RequestEvent = SequenceTypes.RequestEvent;
    type ResponseEvent = SequenceTypes.ResponseEvent;
    type DeleteParams = SequenceTypes.DeleteParams;
    type Settled = SequenceTypes.Settled<State, Participant, Permissions>;
    type Created = SequenceTypes.Created<State, Participant, Permissions>;
    type Success = SequenceTypes.Success<State, Participant>;
    type Failed = SequenceTypes.Failed;
    type Outcome = SequenceTypes.Outcome<State, Participant>;
    interface State {
        metadata?: AppMetadata;
    }
    type DefaultSignalParams = SequenceTypes.DefaultSignalParams<ProposedPeer>;
    type Notification = SequenceTypes.Notification;
    type NotificationEvent = SequenceTypes.NotificationEvent;
    type NotifyParams = SequenceTypes.NotifyParams;
    type Engine = IEngine<Pending, Settled, Upgrade, Update, CreateParams, RespondParams, RequestParams, UpgradeParams, UpdateParams, DeleteParams, ProposeParams, SettleParams, NotifyParams, Participant, Permissions>;
}
export declare abstract class IPairing extends ISequence<PairingTypes.Engine, PairingTypes.Config, PairingTypes.Pending, PairingTypes.Settled, PairingTypes.Upgrade, PairingTypes.Update, PairingTypes.State, PairingTypes.Permissions, PairingTypes.CreateParams, PairingTypes.RespondParams, PairingTypes.RequestParams, PairingTypes.UpgradeParams, PairingTypes.UpdateParams, PairingTypes.DeleteParams, PairingTypes.ProposeParams, PairingTypes.SettleParams, PairingTypes.NotifyParams, PairingTypes.Participant, PairingTypes.Signal, PairingTypes.DefaultSignalParams, PairingTypes.ProposedPermissions> {
}
//# sourceMappingURL=pairing.d.ts.map