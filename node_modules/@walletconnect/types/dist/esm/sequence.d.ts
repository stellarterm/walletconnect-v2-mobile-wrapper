import { Logger } from "pino";
import { JsonRpcPayload, IEvents, RequestArguments, JsonRpcRequest, JsonRpcResponse } from "@walletconnect/jsonrpc-types";
import { IClient } from "./client";
import { CryptoTypes } from "./crypto";
import { ISubscription } from "./subscription";
import { IJsonRpcHistory } from "./history";
import { AppMetadata, BlockchainTypes, JsonRpcPermissions, NotificationPermissions, Reason, SignalTypes } from "./misc";
import { RelayerTypes } from "./relayer";
import { IEngine } from "./engine";
export declare namespace SequenceTypes {
    interface Status {
        proposed: string;
        responded: string;
        pending: string;
        settled: string;
    }
    interface Events {
        proposed: string;
        responded: string;
        settled: string;
        updated: string;
        deleted: string;
        request: string;
        response: string;
        enabled: string;
        disabled: string;
        sync: string;
        notification: string;
    }
    interface JsonRpc {
        propose: string;
        approve: string;
        reject: string;
        update: string;
        upgrade: string;
        delete: string;
        payload: string;
        ping: string;
        notification: string;
    }
    interface Config<E = Events, J = JsonRpc, S = Status> {
        events: E;
        jsonrpc: J;
        status: S;
    }
    type Relay = RelayerTypes.ProtocolOptions;
    interface BasePermissions {
        jsonrpc: JsonRpcPermissions;
        blockchain?: BlockchainTypes.Permissions;
        notifications?: NotificationPermissions;
    }
    interface ProposedPermissions extends BasePermissions {
        blockchain: BlockchainTypes.Permissions;
        notifications: NotificationPermissions;
    }
    interface SettledPermissions extends ProposedPermissions {
        controller: CryptoTypes.Participant;
    }
    type Permissions = SettledPermissions;
    interface ProposeParams {
        relay: Relay;
        timeout?: number;
        signal?: Signal;
        ttl?: number;
        permissions?: ProposedPermissions;
        metadata?: AppMetadata;
    }
    type CreateParams = ProposeParams;
    type Signal = SignalTypes.Base;
    interface Participant extends CryptoTypes.Participant {
        metadata?: AppMetadata;
    }
    interface ProposedPeer extends Participant {
        controller: boolean;
    }
    interface Proposal<S = Signal, Par = ProposedPeer, Per = ProposedPermissions> {
        topic: string;
        relay: Relay;
        proposer: Par;
        signal: S;
        permissions: Per;
        ttl: number;
    }
    type ProposedStatus = "proposed";
    type RespondedStatus = "responded";
    type PendingStatus = ProposedStatus | RespondedStatus;
    interface BasePending<Par = Participant, Pro = Proposal> {
        status: PendingStatus;
        topic: string;
        relay: Relay;
        self: Par;
        proposal: Pro;
    }
    interface ProposedPending<Par = Participant, Pro = Proposal> extends BasePending<Par, Pro> {
        status: ProposedStatus;
    }
    interface RespondedPending<Par = Participant, Pro = Proposal, S = State> extends BasePending<Par, Pro> {
        status: RespondedStatus;
        outcome: Outcome<S, Par>;
    }
    type Pending<Par = Participant, Pro = Proposal, S = State> = ProposedPending<Par, Pro> | RespondedPending<Par, Pro, S>;
    interface RespondParams<Pro = Proposal> {
        approved: boolean;
        proposal: Pro;
        reason?: Reason;
        response?: Response;
    }
    interface SettleParams<S = State, Par = Participant, Per = Permissions> {
        relay: Relay;
        peer: Par;
        self: Par;
        state: S;
        permissions: Per;
        ttl: number;
        expiry: number;
    }
    interface UpgradeParams<Per = Permissions> extends Upgrade<Per> {
        topic: string;
    }
    interface UpdateParams<S = State> extends Update<S> {
        topic: string;
    }
    interface RequestParams {
        topic: string;
        request: RequestArguments;
        timeout?: number;
        chainId?: string;
    }
    interface Upgrade<Per = Permissions> {
        permissions: Partial<Per>;
    }
    interface Update<S = State> {
        state: Partial<S>;
    }
    interface Request {
        request: RequestArguments;
        chainId?: string;
    }
    interface PayloadEvent {
        topic: string;
        payload: JsonRpcPayload;
        chainId?: string;
    }
    interface RequestEvent extends Omit<PayloadEvent, "payload"> {
        request: JsonRpcRequest;
    }
    interface ResponseEvent extends Omit<PayloadEvent, "payload"> {
        response: JsonRpcResponse;
    }
    interface DeleteParams {
        topic: string;
        reason: Reason;
    }
    interface Settled<S = State, Par = Participant, Per = Permissions> {
        topic: string;
        relay: Relay;
        self: Par;
        peer: Par;
        permissions: Per;
        expiry: number;
        state: S;
    }
    type Created<S = State, Par = Participant, Per = Permissions> = Settled<S, Par, Per>;
    interface Success<S = State, Par = Participant> {
        topic: string;
        relay: Relay;
        responder: Par;
        expiry: number;
        state: S;
    }
    interface Failed {
        reason: Reason;
    }
    type Outcome<S = State, Par = Participant> = Failed | Success<S, Par>;
    type State = any;
    interface Response {
        state?: State;
        metadata?: AppMetadata;
    }
    interface DefaultSignalParams<P = ProposedPeer> {
        topic: string;
        relay: Relay;
        proposer: P;
    }
    interface Notification {
        type: string;
        data: any;
    }
    interface NotificationEvent extends Notification {
        topic: string;
    }
    type NotifyParams = NotificationEvent;
    type Engine = IEngine;
}
export declare abstract class ISequence<Engine = SequenceTypes.Engine, Config = SequenceTypes.Config, Pending = SequenceTypes.Pending, Settled = SequenceTypes.Settled, Upgrade = SequenceTypes.Upgrade, Update = SequenceTypes.Update, State = SequenceTypes.State, Permissions = SequenceTypes.Permissions, CreateParams = SequenceTypes.CreateParams, RespondParams = SequenceTypes.RespondParams, RequestParams = SequenceTypes.RequestParams, UpgradeParams = SequenceTypes.UpgradeParams, UpdateParams = SequenceTypes.UpdateParams, DeleteParams = SequenceTypes.DeleteParams, ProposeParams = SequenceTypes.ProposeParams, SettleParams = SequenceTypes.SettleParams, NotifyParams = SequenceTypes.NotifyParams, Participant = SequenceTypes.Participant, Signal = SequenceTypes.Signal, DefaultSignalParams = SequenceTypes.DefaultSignalParams, ProposedPermissions = SequenceTypes.ProposedPermissions> extends IEvents {
    client: IClient;
    logger: Logger;
    abstract pending: ISubscription<Pending>;
    abstract settled: ISubscription<Settled>;
    abstract history: IJsonRpcHistory;
    abstract readonly length: number;
    abstract readonly topics: string[];
    abstract readonly values: Settled[];
    abstract context: string;
    abstract config: Config;
    abstract engine: Engine;
    constructor(client: IClient, logger: Logger);
    abstract init(): Promise<void>;
    abstract get(topic: string): Promise<Settled>;
    abstract find(permissions: Partial<Permissions>): Promise<Settled[]>;
    abstract ping(topic: string, timeout?: number): Promise<void>;
    abstract send(topic: string, payload: JsonRpcPayload, chainId?: string): Promise<void>;
    abstract create(params?: CreateParams): Promise<Settled>;
    abstract respond(params: RespondParams): Promise<Pending>;
    abstract request(params: RequestParams): Promise<any>;
    abstract upgrade(params: UpgradeParams): Promise<Settled>;
    abstract update(params: UpdateParams): Promise<Settled>;
    abstract delete(params: DeleteParams): Promise<void>;
    abstract notify(params: NotifyParams): Promise<void>;
    abstract mergeUpdate(topic: string, update: Update): Promise<State>;
    abstract mergeUpgrade(topic: string, upgrade: Upgrade): Promise<Permissions>;
    abstract validateRespond(params?: RespondParams): Promise<void>;
    abstract validateRequest(params?: RequestParams): Promise<void>;
    abstract validatePropose(params?: ProposeParams): Promise<void>;
    abstract getDefaultSignal(params: DefaultSignalParams): Promise<Signal>;
    abstract getDefaultTTL(): Promise<number>;
    abstract getDefaultPermissions(): Promise<ProposedPermissions>;
}
//# sourceMappingURL=sequence.d.ts.map